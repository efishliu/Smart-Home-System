###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.10194/W32 for 8051         14/Jun/2016  16:18:36 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Components\uCGUI\Cor #
#                          e\GUIAlloc.c                                       #
#    Command line       =  -f F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็ #
#                          \WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\U #
#                          tilities\SerialApp\CC2530DB\..\..\..\Tools\CC2530D #
#                          B\f8wCoord.cfg (-DCPU32MHZ -DROOT=__near_func      #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8         #
#                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)    #
#                          -f F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็ #
#                          \WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\U #
#                          tilities\SerialApp\CC2530DB\..\..\..\Tools\CC2530D #
#                          B\f8wConfig.cfg (-DZIGBEEPRO -DSECURE=0            #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0x1001                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโ #
#                          ลฬืสมฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5. #
#                          1a\Components\uCGUI\Core\GUIAlloc.c -D             #
#                          HAL_UART=TRUE -D SERIAL_APP_PORT=0 -D COOR -D      #
#                          LCD_SUPPORTED -D NV_INIT -lC                       #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\CoordinatorEB\List\ -lA   #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\CoordinatorEB\List\       #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\CoordinatorEB\Obj\ -e     #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็ #
#                          \WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\U #
#                          tilities\SerialApp\CC2530DB\ -I                    #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\Public\ -I             #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \uCGUI\Core\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ2 #
#                          10\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Proj #
#                          ects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\ #
#                          ..\..\Components\uCGUI\MultiLayer\ -I              #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \uCGUI\Config\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสม #
#                          ฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Pr #
#                          ojects\zstack\Utilities\SerialApp\CC2530DB\..\Coor #
#                          dinator\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\Z #
#                          igBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects #
#                          \zstack\Utilities\SerialApp\CC2530DB\..\..\..\ZMai #
#                          n\TI2530DB\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ21 #
#                          0\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Proje #
#                          cts\zstack\Utilities\SerialApp\CC2530DB\..\..\..\. #
#                          .\..\Components\hal\include\ -I                    #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \hal\target\CC2530EB\ -I                           #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \mac\include\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ #
#                          210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Pro #
#                          jects\zstack\Utilities\SerialApp\CC2530DB\..\..\.. #
#                          \..\..\Components\mac\high_level\ -I               #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \mac\low_level\srf04\ -I                           #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \mac\low_level\srf04\single_chip\ -I               #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \mt\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBe #
#                          eอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zst #
#                          ack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\Co #
#                          mponents\osal\include\ -I                          #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \services\saddr\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬื #
#                          สมฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\Components\services\sdata\ -I            #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \stack\af\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210 #
#                          \ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projec #
#                          ts\zstack\Utilities\SerialApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\nwk\ -I                       #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \stack\sapi\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ2 #
#                          10\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Proj #
#                          ects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\ #
#                          ..\..\Components\stack\sec\ -I                     #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \stack\sys\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ21 #
#                          0\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Proje #
#                          cts\zstack\Utilities\SerialApp\CC2530DB\..\..\..\. #
#                          .\..\Components\stack\zdo\ -I                      #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \zmac\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\Zig #
#                          Beeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\z #
#                          stack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\ #
#                          Components\zmac\f8w\ -Ohz --require_prototypes     #
#    List file          =  F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\CoordinatorEB\List\GUIAll #
#                          oc.lst                                             #
#    Object file        =  F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\CoordinatorEB\Obj\GUIAllo #
#                          c.r51                                              #
#                                                                             #
#                                                                             #
###############################################################################

F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Components\uCGUI\Core\GUIAlloc.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              ตC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : GUIAlloc.C
     16          Purpose     : Dynamic memory management
     17          ----------------------------------------------------------------------
     18          */
     19          
     20          #include <stddef.h>           /* needed for definition of NULL */
     21          #include <string.h>           /* for memcpy, memset */
     22          
     23          #include "GUI_Protected.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
     24          #include "GUIDebug.h"
     25          
     26          /*********************************************************************
     27          *
     28          *       Internal memory management
     29          *
     30          **********************************************************************
     31          */
     32          
     33          #ifndef GUI_ALLOC_ALLOC
     34          
     35          #if GUI_ALLOC_SIZE==0
     36            #error GUI_ALLOC_SIZE needs to be > 0 when using this module
     37          #endif
     38          
     39          /*********************************************************************
     40          *
     41          *       Defines, config defaults
     42          *
     43          **********************************************************************
     44          */
     45          
     46          /* Permit automatic defragmentation when necessary */
     47          #ifndef GUI_ALLOC_AUTDEFRAG
     48            #define GUI_ALLOC_AUTDEFRAG 1
     49          #endif
     50          
     51          #ifndef GUI_BLOCK_ALIGN        /* 2 means 4 bytes, 1 means 2 bytes      */
     52            #define GUI_BLOCK_ALIGN 2    /* 1 can be used on 16-bit CPUs and CPUs */
     53          #endif                         /* which do not require aligned 32-bit   */
     54                                         /* values (such as x86)                  */ 
     55          
     56          #ifndef GUI_MAXBLOCKS
     57            #define GUI_MAXBLOCKS (2 + GUI_ALLOC_SIZE / 32)
     58          #endif
     59          
     60          #ifndef GUI_ALLOC_LOCATION
     61            #define GUI_ALLOC_LOCATION
     62          #endif
     63          
     64          #ifndef GUI_MEM_ALLOC          /* Allows us in some systems to place the GUI memory */
     65            #define GUI_MEM_ALLOC        /* in a different memory space ... eg "__far"        */
     66          #endif
     67          
     68          /*********************************************************************
     69          *
     70          *       Defines
     71          *
     72          **********************************************************************
     73          */
     74          
     75          #define Min(v0,v1) ((v0>v1) ? v1 : v0)
     76          #define Max(v0,v1) ((v0>v1) ? v0 : v1)
     77          #define ASSIGN_IF_LESS(v0,v1) if (v1<v0) v0=v1
     78          #define HMEM2PTR(hMem) (void*)&GUI_Heap.abHeap[aBlock[hMem].Off]
     79          
     80          #if GUI_MAXBLOCKS >= 256
     81            #define HANDLE U16
     82          #else
     83            #define HANDLE U8
     84          #endif
     85          
     86          /*********************************************************************
     87          *
     88          *       Types
     89          *
     90          **********************************************************************
     91          */
     92          
     93          typedef union {
     94            int aintHeap[GUI_ALLOC_SIZE / 4];   /* required for proper alignement */
     95            U8  abHeap[GUI_ALLOC_SIZE];
     96          } GUI_HEAP;
     97          
     98          typedef struct {
     99            GUI_ALLOC_DATATYPE Off;       /* Offset of memory area          */
    100            GUI_ALLOC_DATATYPE Size;      /* usable size of allocated block */
    101            HANDLE Next;         /* next handle in linked list     */
    102            HANDLE Prev;
    103          } tBlock;
    104          
    105          /*********************************************************************
    106          *
    107          *       Static data
    108          *
    109          **********************************************************************
    110          */
    111          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    112          GUI_MEM_ALLOC GUI_HEAP GUI_Heap GUI_ALLOC_LOCATION;         /* Public for debugging only */
   \                     GUI_Heap:
   \   000000                DS 1024
   \   000400                REQUIRE __INIT_XDATA_Z
    113          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    114          static tBlock aBlock[GUI_MAXBLOCKS];
   \                     aBlock:
   \   000000                DS 204
   \   0000CC                REQUIRE __INIT_XDATA_Z
    115          
    116          struct {
    117            int       NumUsedBlocks, NumFreeBlocks, NumFreeBlocksMin; /* For statistical purposes only */
    118            GUI_ALLOC_DATATYPE NumUsedBytes,  NumFreeBytes,  NumFreeBytesMin;

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    119          } GUI_ALLOC;
   \                     GUI_ALLOC:
   \   000000                DS 12
   \   00000C                REQUIRE __INIT_XDATA_Z
    120          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    121          static char   IsInitialized =0;
   \                     IsInitialized:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    122          
    123          /*********************************************************************
    124          *
    125          *       Static code
    126          *
    127          **********************************************************************
    128          */
    129          /*********************************************************************
    130          *
    131          *       _Size2LegalSize
    132          *
    133          * Return value:
    134          *   Legal allocation size
    135          */
    136          static GUI_ALLOC_DATATYPE _Size2LegalSize(GUI_ALLOC_DATATYPE size) {
    137            return (size + ((1 << GUI_BLOCK_ALIGN) - 1)) & ~((1 << GUI_BLOCK_ALIGN) - 1);
    138          }
    139            
    140          /*********************************************************************
    141          *
    142          *       _GetSize
    143          */
    144          static GUI_ALLOC_DATATYPE _GetSize(GUI_HMEM  hMem) {
    145            return aBlock[hMem].Size;
    146          }
    147          
    148          /*********************************************************************
    149          *
    150          *       _Free
    151          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    152          static void _Free(GUI_HMEM hMem) {
   \                     _Free:
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    153            GUI_ALLOC_DATATYPE Size;
    154            GUI_DEBUG_LOG1("\nGUI_ALLOC_Free(%d)", hMem);
    155            /* Do some error checking ... */
    156            #if GUI_DEBUG_LEVEL>0
    157              /* Block not allocated ? */
    158              if (aBlock[hMem].Size == 0) {
   \   000005   EA           MOV     A,R2
   \   000006   F8           MOV     R0,A
   \   000007   EB           MOV     A,R3
   \   000008   F9           MOV     R1,A
   \   000009   E8           MOV     A,R0
   \   00000A   75F006       MOV     B,#0x6
   \   00000D   A4           MUL     AB
   \   00000E   F8           MOV     R0,A
   \   00000F   ACF0         MOV     R4,B
   \   000011   75F006       MOV     B,#0x6
   \   000014   E9           MOV     A,R1
   \   000015   A4           MUL     AB
   \   000016   2C           ADD     A,R4
   \   000017   F9           MOV     R1,A
   \   000018   74..         MOV     A,#(aBlock + 2) & 0xff
   \   00001A   28           ADD     A,R0
   \   00001B   F582         MOV     DPL,A
   \   00001D   74..         MOV     A,#((aBlock + 2) >> 8) & 0xff
   \   00001F   39           ADDC    A,R1
   \   000020   F583         MOV     DPH,A
   \   000022   12....       LCALL   ??Subroutine27_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000025   E8           MOV     A,R0
   \   000026   49           ORL     A,R1
   \   000027   6078         JZ      ??CrossCallReturnLabel_12
    159                GUI_DEBUG_ERROROUT("GUI_ALLOC_Free(): Invalid hMem");
    160                return;
    161              }
    162            #endif
    163            Size = aBlock[hMem].Size;
   \   000029   EA           MOV     A,R2
   \   00002A   75F006       MOV     B,#0x6
   \   00002D   A4           MUL     AB
   \   00002E   FA           MOV     R2,A
   \   00002F   A8F0         MOV     R0,B
   \   000031   75F006       MOV     B,#0x6
   \   000034   EB           MOV     A,R3
   \   000035   A4           MUL     AB
   \   000036   28           ADD     A,R0
   \   000037   FB           MOV     R3,A
   \   000038   74..         MOV     A,#aBlock & 0xff
   \   00003A   2A           ADD     A,R2
   \   00003B   F8           MOV     R0,A
   \   00003C   74..         MOV     A,#(aBlock >> 8) & 0xff
   \   00003E   3B           ADDC    A,R3
   \   00003F   F9           MOV     R1,A
   \   000040   E8           MOV     A,R0
   \   000041   FA           MOV     R2,A
   \   000042   E9           MOV     A,R1
   \   000043   FB           MOV     R3,A
   \   000044   EA           MOV     A,R2
   \   000045   2402         ADD     A,#0x2
   \   000047   08           INC     R0
   \   000048   08           INC     R0
   \   000049   EB           MOV     A,R3
   \   00004A   3400         ADDC    A,#0x0
   \   00004C   F9           MOV     R1,A
   \   00004D   12....       LCALL   ?Subroutine22 & 0xFFFF
    164            #ifdef WIN32
    165              GUI_MEMSET(&GUI_Heap.abHeap[aBlock[hMem].Off], 0xcc, Size);
    166            #endif
    167            GUI_ALLOC.NumFreeBytes += Size;
   \                     ??CrossCallReturnLabel_29:
   \   000050   90....       MOV     DPTR,#GUI_ALLOC + 8
   \   000053   E0           MOVX    A,@DPTR
   \   000054   2C           ADD     A,R4
   \   000055   F0           MOVX    @DPTR,A
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   3D           ADDC    A,R5
   \   000059   F0           MOVX    @DPTR,A
    168            GUI_ALLOC.NumUsedBytes -= Size;
   \   00005A   90....       MOV     DPTR,#GUI_ALLOC + 6
   \   00005D   C3           CLR     C
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   9C           SUBB    A,R4
   \   000060   F0           MOVX    @DPTR,A
   \   000061   A3           INC     DPTR
   \   000062   E0           MOVX    A,@DPTR
   \   000063   9D           SUBB    A,R5
   \   000064   F0           MOVX    @DPTR,A
    169            aBlock[hMem].Size = 0;
   \   000065   8882         MOV     DPL,R0
   \   000067   8983         MOV     DPH,R1
   \   000069   E4           CLR     A
   \   00006A   F0           MOVX    @DPTR,A
   \   00006B   A3           INC     DPTR
   \   00006C   F0           MOVX    @DPTR,A
    170            {
    171              int Next = aBlock[hMem].Next;
   \   00006D   8A82         MOV     DPL,R2
   \   00006F   8B83         MOV     DPH,R3
   \   000071   A3           INC     DPTR
   \   000072   A3           INC     DPTR
   \   000073   A3           INC     DPTR
   \   000074   A3           INC     DPTR
   \   000075   E0           MOVX    A,@DPTR
   \   000076   F8           MOV     R0,A
    172              int Prev = aBlock[hMem].Prev;
   \   000077   8A82         MOV     DPL,R2
   \   000079   8B83         MOV     DPH,R3
   \   00007B   A3           INC     DPTR
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   A3           INC     DPTR
   \   00007F   A3           INC     DPTR
   \   000080   E0           MOVX    A,@DPTR
   \   000081   FC           MOV     R4,A
    173              aBlock[Prev].Next = Next;
   \   000082   75F006       MOV     B,#0x6
   \   000085   A4           MUL     AB
   \   000086   FA           MOV     R2,A
   \   000087   ABF0         MOV     R3,B
   \   000089   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   00008C   E8           MOV     A,R0
   \   00008D   F0           MOVX    @DPTR,A
    174              if (Next) {
   \   00008E   6005         JZ      ??_Free_0
    175                aBlock[Next].Prev = Prev;
   \   000090   12....       LCALL   ?Subroutine3 & 0xFFFF
    176              }
    177            }  
   \                     ??CrossCallReturnLabel_32:
   \   000093   EC           MOV     A,R4
   \   000094   F0           MOVX    @DPTR,A
    178            GUI_ALLOC.NumFreeBlocks++;
   \                     ??_Free_0:
   \   000095   90....       MOV     DPTR,#GUI_ALLOC + 2
   \   000098   12....       LCALL   ?Subroutine11 & 0xFFFF
    179            GUI_ALLOC.NumUsedBlocks--;
   \                     ??CrossCallReturnLabel_10:
   \   00009B   90....       MOV     DPTR,#GUI_ALLOC
   \   00009E   12....       LCALL   ?Subroutine12 & 0xFFFF
    180          }
   \                     ??CrossCallReturnLabel_12:
   \   0000A1                REQUIRE ?Subroutine0
   \   0000A1                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004                REQUIRE ??Subroutine23_0
   \   000004                ; // Fall through to label ??Subroutine23_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine23_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   75F006       MOV     B,#0x6
   \   000003   A4           MUL     AB
   \   000004   F8           MOV     R0,A
   \   000005   A9F0         MOV     R1,B
   \   000007                REQUIRE ??Subroutine24_0
   \   000007                ; // Fall through to label ??Subroutine24_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine24_0:
   \   000000   74..         MOV     A,#(aBlock + 5) & 0xff
   \   000002   28           ADD     A,R0
   \   000003   F582         MOV     DPL,A
   \   000005   74..         MOV     A,#((aBlock + 5) >> 8) & 0xff
   \   000007   39           ADDC    A,R1
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   74..         MOV     A,#(aBlock + 4) & 0xff
   \   000002   2A           ADD     A,R2
   \   000003   F582         MOV     DPL,A
   \   000005   74..         MOV     A,#((aBlock + 4) >> 8) & 0xff
   \   000007   3B           ADDC    A,R3
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   24FF         ADD     A,#-0x1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   34FF         ADDC    A,#-0x1
   \   000008   F0           MOVX    @DPTR,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2401         ADD     A,#0x1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   F0           MOVX    @DPTR,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine27_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    181          
    182          /*********************************************************************
    183          *
    184          *       _FindFreeHandle
    185          *
    186          * Return value:
    187          *   Free handle
    188          */
    189          static GUI_HMEM _FindFreeHandle(void) {
    190            int i;
    191            for (i=1; i< GUI_MAXBLOCKS; i++) {
    192              if (aBlock[i].Size ==0)
    193          	  return i;
    194            }
    195            GUI_DEBUG_ERROROUT1("Insufficient memory handles configured (GUI_MAXBLOCKS == %d (See GUIConf.h))", GUI_MAXBLOCKS);
    196            return GUI_HMEM_NULL;
    197          }
    198          
    199          /*********************************************************************
    200          *
    201          *       _FindHole
    202          *
    203          * Return value:
    204          *   Offset to the memory hole (if available)
    205          *   -1 if not available
    206          */
    207          static GUI_HMEM _FindHole(GUI_ALLOC_DATATYPE Size) {
    208            int i, iNext;
    209            for (i=0; (iNext = aBlock[i].Next) != 0; i = iNext) {
    210              int NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
    211              if (NumFreeBytes>=Size) {
    212                return i;
    213              }
    214            }
    215            /* Check last block */
    216            if (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size) >= Size) {
    217              return i;
    218            }
    219            return -1;
    220          }
    221          
    222          /*********************************************************************
    223          *
    224          *       _CreateHole
    225          *
    226          * Return value:
    227          *   Offset to the memory hole (if available)
    228          *   -1 if not available
    229          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    230          static GUI_HMEM _CreateHole(GUI_ALLOC_DATATYPE Size) {
   \                     _CreateHole:
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 6,R2
   \   000007   8B..         MOV     ?V0 + 7,R3
    231            int i, iNext;
    232            int r = -1;
   \   000009   75..FF       MOV     ?V0 + 0,#-0x1
   \   00000C   75..FF       MOV     ?V0 + 1,#-0x1
    233            for (i=0; (iNext =aBlock[i].Next) !=0; i= iNext) {
   \   00000F   7800         MOV     R0,#0x0
   \   000011   02....       LJMP    ??_CreateHole_0 & 0xFFFF
    234              GUI_ALLOC_DATATYPE NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
    235              if (NumFreeBytes < Size) {
   \                     ??_CreateHole_1:
   \   000014   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000017   EE           MOV     A,R6
   \   000018   75F006       MOV     B,#0x6
   \   00001B   A4           MUL     AB
   \   00001C   FC           MOV     R4,A
   \   00001D   85F0..       MOV     ?V0 + 2,B
   \   000020   AD..         MOV     R5,?V0 + 2
   \   000022   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000025   C082         PUSH    DPL
   \   000027   C083         PUSH    DPH
   \   000029   8A82         MOV     DPL,R2
   \   00002B   8B83         MOV     DPH,R3
   \   00002D   12....       LCALL   ??Subroutine23_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   000030   D083         POP     DPH
   \   000032   D082         POP     DPL
   \   000034   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000037   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   00003A   EC           MOV     A,R4
   \   00003B   C3           CLR     C
   \   00003C   9A           SUBB    A,R2
   \   00003D   FA           MOV     R2,A
   \   00003E   ED           MOV     A,R5
   \   00003F   9B           SUBB    A,R3
   \   000040   FB           MOV     R3,A
   \   000041   C3           CLR     C
   \   000042   EA           MOV     A,R2
   \   000043   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   000046   4003         JC      $+5
   \   000048   02....       LJMP    ??_CreateHole_2 & 0xFFFF
    236                GUI_ALLOC_DATATYPE NumBytesBeforeBlock = aBlock[iNext].Off - (aBlock[i].Off+aBlock[i].Size);
   \   00004B   E8           MOV     A,R0
   \   00004C   75F006       MOV     B,#0x6
   \   00004F   A4           MUL     AB
   \   000050   F8           MOV     R0,A
   \   000051   A9F0         MOV     R1,B
   \   000053   74..         MOV     A,#aBlock & 0xff
   \   000055   28           ADD     A,R0
   \   000056   FA           MOV     R2,A
   \   000057   74..         MOV     A,#(aBlock >> 8) & 0xff
   \   000059   39           ADDC    A,R1
   \   00005A   FB           MOV     R3,A
   \   00005B   EE           MOV     A,R6
   \   00005C   75F006       MOV     B,#0x6
   \   00005F   A4           MUL     AB
   \   000060   F8           MOV     R0,A
   \   000061   A9F0         MOV     R1,B
   \   000063   74..         MOV     A,#aBlock & 0xff
   \   000065   28           ADD     A,R0
   \   000066   F582         MOV     DPL,A
   \   000068   74..         MOV     A,#(aBlock >> 8) & 0xff
   \   00006A   39           ADDC    A,R1
   \   00006B   F583         MOV     DPH,A
   \   00006D   C082         PUSH    DPL
   \   00006F   C083         PUSH    DPH
   \   000071   8A82         MOV     DPL,R2
   \   000073   8B83         MOV     DPH,R3
   \   000075   12....       LCALL   ??Subroutine27_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000078   D083         POP     DPH
   \   00007A   D082         POP     DPL
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   C3           CLR     C
   \   00007E   98           SUBB    A,R0
   \   00007F   F8           MOV     R0,A
   \   000080   A3           INC     DPTR
   \   000081   E0           MOVX    A,@DPTR
   \   000082   99           SUBB    A,R1
   \   000083   F9           MOV     R1,A
   \   000084   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000087   E8           MOV     A,R0
   \   000088   C3           CLR     C
   \   000089   9A           SUBB    A,R2
   \   00008A   F5..         MOV     ?V0 + 2,A
   \   00008C   E9           MOV     A,R1
   \   00008D   9B           SUBB    A,R3
   \   00008E   F5..         MOV     ?V0 + 3,A
    237                if (NumBytesBeforeBlock) {
   \   000090   E5..         MOV     A,?V0 + 2
   \   000092   45..         ORL     A,?V0 + 3
   \   000094   6052         JZ      ??_CreateHole_2
    238                  U8* pData = &GUI_Heap.abHeap[aBlock[iNext].Off];
   \   000096   EE           MOV     A,R6
   \   000097   75F006       MOV     B,#0x6
   \   00009A   A4           MUL     AB
   \   00009B   F8           MOV     R0,A
   \   00009C   A9F0         MOV     R1,B
   \   00009E   74..         MOV     A,#aBlock & 0xff
   \   0000A0   28           ADD     A,R0
   \   0000A1   F5..         MOV     ?V0 + 4,A
   \   0000A3   74..         MOV     A,#(aBlock >> 8) & 0xff
   \   0000A5   39           ADDC    A,R1
   \   0000A6   F5..         MOV     ?V0 + 5,A
   \   0000A8   85..82       MOV     DPL,?V0 + 4
   \   0000AB   F583         MOV     DPH,A
   \   0000AD   E0           MOVX    A,@DPTR
   \   0000AE   24..         ADD     A,#GUI_Heap & 0xff
   \   0000B0   FC           MOV     R4,A
   \   0000B1   A3           INC     DPTR
   \   0000B2   E0           MOVX    A,@DPTR
   \   0000B3   34..         ADDC    A,#(GUI_Heap >> 8) & 0xff
   \   0000B5   FD           MOV     R5,A
    239                  memmove(pData-NumBytesBeforeBlock, pData, aBlock[iNext].Size);
   \   0000B6                ; Setup parameters for call to function memmove
   \   0000B6   85..82       MOV     DPL,?V0 + 4
   \   0000B9   85..83       MOV     DPH,?V0 + 5
   \   0000BC   A3           INC     DPTR
   \   0000BD   A3           INC     DPTR
   \   0000BE   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000C1   C3           CLR     C
   \   0000C2   E4           CLR     A
   \   0000C3   95..         SUBB    A,?V0 + 2
   \   0000C5   F8           MOV     R0,A
   \   0000C6   E4           CLR     A
   \   0000C7   95..         SUBB    A,?V0 + 3
   \   0000C9   F9           MOV     R1,A
   \   0000CA   EC           MOV     A,R4
   \   0000CB   28           ADD     A,R0
   \   0000CC   FA           MOV     R2,A
   \   0000CD   ED           MOV     A,R5
   \   0000CE   39           ADDC    A,R1
   \   0000CF   FB           MOV     R3,A
   \   0000D0   12....       LCALL   ??memmove?relay
   \   0000D3   7402         MOV     A,#0x2
   \   0000D5   12....       LCALL   ?DEALLOC_XSTACK8
    240                  aBlock[iNext].Off -=NumBytesBeforeBlock;
   \   0000D8   85..82       MOV     DPL,?V0 + 4
   \   0000DB   85..83       MOV     DPH,?V0 + 5
   \   0000DE   C3           CLR     C
   \   0000DF   E0           MOVX    A,@DPTR
   \   0000E0   95..         SUBB    A,?V0 + 2
   \   0000E2   F0           MOVX    @DPTR,A
   \   0000E3   A3           INC     DPTR
   \   0000E4   E0           MOVX    A,@DPTR
   \   0000E5   95..         SUBB    A,?V0 + 3
   \   0000E7   F0           MOVX    @DPTR,A
    241                }
    242              }
    243            }
   \                     ??_CreateHole_2:
   \   0000E8   EE           MOV     A,R6
   \   0000E9   F8           MOV     R0,A
   \                     ??_CreateHole_0:
   \   0000EA   7900         MOV     R1,#0x0
   \   0000EC   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   0000EF   FE           MOV     R6,A
   \   0000F0   6003         JZ      $+5
   \   0000F2   02....       LJMP    ??_CreateHole_1 & 0xFFFF
    244            /* Check last block */
    245            if (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size) >= Size) {
   \   0000F5   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   0000F8   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   0000FB   4004         JC      ??_CreateHole_3
    246              r = i;
   \   0000FD   88..         MOV     ?V0 + 0,R0
   \   0000FF   89..         MOV     ?V0 + 1,R1
    247            }
    248            return r;
   \                     ??_CreateHole_3:
   \   000101   AA..         MOV     R2,?V0 + 0
   \   000103   AB..         MOV     R3,?V0 + 1
   \   000105   7F08         MOV     R7,#0x8
   \   000107   02....       LJMP    ?BANKED_LEAVE_XDATA
    249          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   95..         SUBB    A,?V0 + 6
   \   000002   EB           MOV     A,R3
   \   000003   95..         SUBB    A,?V0 + 7
   \   000005   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000007   65D0         XRL     A,PSW
   \   000009   33           RLC     A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   E8           MOV     A,R0
   \   000001   75F006       MOV     B,#0x6
   \   000004   A4           MUL     AB
   \   000005   FA           MOV     R2,A
   \   000006   ABF0         MOV     R3,B
   \   000008                REQUIRE ??Subroutine25_0
   \   000008                ; // Fall through to label ??Subroutine25_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine25_0:
   \   000000   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   74..         MOV     A,#aBlock & 0xff
   \   000002   2A           ADD     A,R2
   \   000003   FA           MOV     R2,A
   \   000004   74..         MOV     A,#(aBlock >> 8) & 0xff
   \   000006   3B           ADDC    A,R3
   \   000007   FB           MOV     R3,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   000003   8A82         MOV     DPL,R2
   \   000005   8B83         MOV     DPH,R3
   \   000007   12....       LCALL   ??Subroutine23_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   00000A   E4           CLR     A
   \   00000B   C3           CLR     C
   \   00000C   9C           SUBB    A,R4
   \   00000D   FC           MOV     R4,A
   \   00000E   7404         MOV     A,#0x4
   \   000010   9D           SUBB    A,R5
   \   000011   FD           MOV     R5,A
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   FA           MOV     R2,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   FB           MOV     R3,A
   \   00001D   EC           MOV     A,R4
   \   00001E   C3           CLR     C
   \   00001F   9A           SUBB    A,R2
   \   000020   FA           MOV     R2,A
   \   000021   ED           MOV     A,R5
   \   000022   9B           SUBB    A,R3
   \   000023   FB           MOV     R3,A
   \   000024   C3           CLR     C
   \   000025   EA           MOV     A,R2
   \   000026   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   C3           CLR     C
   \   000002   9C           SUBB    A,R4
   \   000003   FC           MOV     R4,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   9D           SUBB    A,R5
   \   000007   FD           MOV     R5,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   74..         MOV     A,#aBlock & 0xff
   \   000002   2C           ADD     A,R4
   \   000003   F582         MOV     DPL,A
   \   000005   74..         MOV     A,#(aBlock >> 8) & 0xff
   \   000007   3D           ADDC    A,R5
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006                REQUIRE ??Subroutine28_0
   \   000006                ; // Fall through to label ??Subroutine28_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine28_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    250          
    251          /*********************************************************************
    252          *
    253          *       _CheckInit
    254          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    255          static void _CheckInit(void) {
   \                     _CheckInit:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    256            if (!IsInitialized) {
   \   000004   90....       MOV     DPTR,#IsInitialized
   \   000007   E0           MOVX    A,@DPTR
   \   000008   7003         JNZ     ??_CheckInit_0
    257              GUI_ALLOC_Init();
   \   00000A                ; Setup parameters for call to function GUI_ALLOC_Init
   \   00000A   12....       LCALL   ??GUI_ALLOC_Init?relay
    258            }
    259          }
   \                     ??_CheckInit_0:
   \   00000D   02....       LJMP    ?Subroutine1 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    260          
    261          /*********************************************************************
    262          *
    263          *       _Alloc
    264          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    265          static GUI_HMEM _Alloc(GUI_ALLOC_DATATYPE size) {
   \                     _Alloc:
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    266            GUI_HMEM hMemNew, hMemIns;
    267            _CheckInit();
   \   000009                ; Setup parameters for call to function _CheckInit
   \   000009   12....       LCALL   ??_CheckInit?relay
    268            size = _Size2LegalSize(size);
   \   00000C   EE           MOV     A,R6
   \   00000D   2403         ADD     A,#0x3
   \   00000F   F8           MOV     R0,A
   \   000010   EF           MOV     A,R7
   \   000011   3400         ADDC    A,#0x0
   \   000013   F9           MOV     R1,A
   \   000014   E8           MOV     A,R0
   \   000015   54FC         ANL     A,#0xfc
   \   000017   FE           MOV     R6,A
   \   000018   E9           MOV     A,R1
   \   000019   FF           MOV     R7,A
    269            /* Check if memory is available at all ...*/
    270            if (size > GUI_ALLOC.NumFreeBytes) {
   \   00001A   90....       MOV     DPTR,#GUI_ALLOC + 8
   \   00001D   C3           CLR     C
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   9E           SUBB    A,R6
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   12....       LCALL   ??Subroutine26_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000025   5007         JNC     ??_Alloc_0
    271              GUI_DEBUG_WARN1("GUI_ALLOC_Alloc: Insufficient memory configured (Trying to alloc % bytes)", size);
    272              return 0;
   \                     ??_Alloc_1:
   \   000027   7A00         MOV     R2,#0x0
   \   000029   7B00         MOV     R3,#0x0
   \   00002B   02....       LJMP    ??_Alloc_2 & 0xFFFF
    273            }
    274            /* Locate free handle */
    275            if ((hMemNew = _FindFreeHandle()) == 0)
   \                     ??_Alloc_0:
   \   00002E   7801         MOV     R0,#0x1
   \   000030   7900         MOV     R1,#0x0
   \                     ??_Alloc_3:
   \   000032   E8           MOV     A,R0
   \   000033   FA           MOV     R2,A
   \   000034   E9           MOV     A,R1
   \   000035   FB           MOV     R3,A
   \   000036   EA           MOV     A,R2
   \   000037   75F006       MOV     B,#0x6
   \   00003A   A4           MUL     AB
   \   00003B   FA           MOV     R2,A
   \   00003C   ACF0         MOV     R4,B
   \   00003E   75F006       MOV     B,#0x6
   \   000041   EB           MOV     A,R3
   \   000042   A4           MUL     AB
   \   000043   2C           ADD     A,R4
   \   000044   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000047   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   00004A   EA           MOV     A,R2
   \   00004B   4B           ORL     A,R3
   \   00004C   700E         JNZ     ??_Alloc_4
   \   00004E   88..         MOV     ?V0 + 0,R0
   \   000050   89..         MOV     ?V0 + 1,R1
   \   000052   E5..         MOV     A,?V0 + 0
   \   000054   45..         ORL     A,?V0 + 1
   \   000056   60CF         JZ      ??_Alloc_1
    276              return 0;
    277            /* Locate or Create hole of sufficient size */
    278            hMemIns = _FindHole(size);
   \   000058   7800         MOV     R0,#0x0
   \   00005A   8069         SJMP    ??_Alloc_5
   \                     ??_Alloc_4:
   \   00005C   E8           MOV     A,R0
   \   00005D   2401         ADD     A,#0x1
   \   00005F   08           INC     R0
   \   000060   E9           MOV     A,R1
   \   000061   3400         ADDC    A,#0x0
   \   000063   F9           MOV     R1,A
   \   000064   C3           CLR     C
   \   000065   E8           MOV     A,R0
   \   000066   9422         SUBB    A,#0x22
   \   000068   E9           MOV     A,R1
   \   000069   9400         SUBB    A,#0x0
   \   00006B   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00006D   65D0         XRL     A,PSW
   \   00006F   33           RLC     A
   \   000070   50B5         JNC     ??_Alloc_1
   \   000072   80BE         SJMP    ??_Alloc_3
   \                     ??_Alloc_6:
   \   000074   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   000077   EC           MOV     A,R4
   \   000078   75F006       MOV     B,#0x6
   \   00007B   A4           MUL     AB
   \   00007C   F5..         MOV     ?V0 + 2,A
   \   00007E   85F0..       MOV     ?V0 + 4,B
   \   000081   E5..         MOV     A,?V0 + 4
   \   000083   F5..         MOV     ?V0 + 3,A
   \   000085   74..         MOV     A,#aBlock & 0xff
   \   000087   25..         ADD     A,?V0 + 2
   \   000089   F582         MOV     DPL,A
   \   00008B   74..         MOV     A,#(aBlock >> 8) & 0xff
   \   00008D   35..         ADDC    A,?V0 + 3
   \   00008F   F583         MOV     DPH,A
   \   000091   C082         PUSH    DPL
   \   000093   C083         PUSH    DPH
   \   000095   8A82         MOV     DPL,R2
   \   000097   8B83         MOV     DPH,R3
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   F5..         MOV     ?V0 + 2,A
   \   00009C   A3           INC     DPTR
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   F5..         MOV     ?V0 + 3,A
   \   0000A0   D083         POP     DPH
   \   0000A2   D082         POP     DPL
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   C3           CLR     C
   \   0000A6   95..         SUBB    A,?V0 + 2
   \   0000A8   F5..         MOV     ?V0 + 2,A
   \   0000AA   A3           INC     DPTR
   \   0000AB   E0           MOVX    A,@DPTR
   \   0000AC   95..         SUBB    A,?V0 + 3
   \   0000AE   F5..         MOV     ?V0 + 3,A
   \   0000B0   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   0000B3   E5..         MOV     A,?V0 + 2
   \   0000B5   C3           CLR     C
   \   0000B6   9A           SUBB    A,R2
   \   0000B7   FA           MOV     R2,A
   \   0000B8   E5..         MOV     A,?V0 + 3
   \   0000BA   9B           SUBB    A,R3
   \   0000BB   FB           MOV     R3,A
   \   0000BC   C3           CLR     C
   \   0000BD   EA           MOV     A,R2
   \   0000BE   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   0000C1   5010         JNC     ??_Alloc_7
   \   0000C3   EC           MOV     A,R4
   \   0000C4   F8           MOV     R0,A
   \                     ??_Alloc_5:
   \   0000C5   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   0000C8   FC           MOV     R4,A
   \   0000C9   70A9         JNZ     ??_Alloc_6
   \   0000CB   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0000CE   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   0000D1   400D         JC      ??_Alloc_8
   \                     ??_Alloc_7:
   \   0000D3   E8           MOV     A,R0
   \   0000D4   FA           MOV     R2,A
   \   0000D5   7B00         MOV     R3,#0x0
    279            #if GUI_ALLOC_AUTDEFRAG
    280              if (hMemIns == -1) {
   \   0000D7   74FF         MOV     A,#-0x1
   \   0000D9   6A           XRL     A,R2
   \   0000DA   7002         JNZ     ??_Alloc_9
   \   0000DC   74FF         MOV     A,#-0x1
   \                     ??_Alloc_9:
   \   0000DE   7007         JNZ     ??_Alloc_10
    281                hMemIns = _CreateHole(size);
   \                     ??_Alloc_8:
   \   0000E0                ; Setup parameters for call to function _CreateHole
   \   0000E0   EE           MOV     A,R6
   \   0000E1   FA           MOV     R2,A
   \   0000E2   EF           MOV     A,R7
   \   0000E3   FB           MOV     R3,A
   \   0000E4   12....       LCALL   ??_CreateHole?relay
    282              }
    283            #endif
    284            /* Occupy hole */
    285            if (hMemIns==-1) {
   \                     ??_Alloc_10:
   \   0000E7   74FF         MOV     A,#-0x1
   \   0000E9   6A           XRL     A,R2
   \   0000EA   7003         JNZ     ??_Alloc_11
   \   0000EC   74FF         MOV     A,#-0x1
   \   0000EE   6B           XRL     A,R3
   \                     ??_Alloc_11:
   \   0000EF   7003         JNZ     $+5
   \   0000F1   02....       LJMP    ??_Alloc_1 & 0xFFFF
    286              GUI_DEBUG_ERROROUT1("GUI_ALLOC_Alloc: Could not allocate %d bytes",size);
    287              return 0;
    288          	}
    289            {
    290              GUI_ALLOC_DATATYPE Off = aBlock[hMemIns].Off + aBlock[hMemIns].Size;
   \   0000F4   EA           MOV     A,R2
   \   0000F5   F8           MOV     R0,A
   \   0000F6   EB           MOV     A,R3
   \   0000F7   F9           MOV     R1,A
   \   0000F8   E8           MOV     A,R0
   \   0000F9   75F006       MOV     B,#0x6
   \   0000FC   A4           MUL     AB
   \   0000FD   F8           MOV     R0,A
   \   0000FE   ACF0         MOV     R4,B
   \   000100   75F006       MOV     B,#0x6
   \   000103   E9           MOV     A,R1
   \   000104   A4           MUL     AB
   \   000105   2C           ADD     A,R4
   \   000106   F9           MOV     R1,A
   \   000107   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   00010A   FC           MOV     R4,A
   \   00010B   A3           INC     DPTR
   \   00010C   E0           MOVX    A,@DPTR
   \   00010D   FD           MOV     R5,A
   \   00010E   8882         MOV     DPL,R0
   \   000110   8983         MOV     DPH,R1
   \   000112   A3           INC     DPTR
   \   000113   A3           INC     DPTR
   \   000114   E0           MOVX    A,@DPTR
   \   000115   2C           ADD     A,R4
   \   000116   F5..         MOV     ?V0 + 2,A
   \   000118   A3           INC     DPTR
   \   000119   E0           MOVX    A,@DPTR
   \   00011A   3D           ADDC    A,R5
   \   00011B   F5..         MOV     ?V0 + 3,A
    291              int Next = aBlock[hMemIns].Next;
   \   00011D   8882         MOV     DPL,R0
   \   00011F   8983         MOV     DPH,R1
   \   000121   A3           INC     DPTR
   \   000122   A3           INC     DPTR
   \   000123   A3           INC     DPTR
   \   000124   A3           INC     DPTR
   \   000125   E0           MOVX    A,@DPTR
   \   000126   F8           MOV     R0,A
    292              aBlock[hMemNew].Size  = size;
   \   000127   E5..         MOV     A,?V0 + 0
   \   000129   75F006       MOV     B,#0x6
   \   00012C   A4           MUL     AB
   \   00012D   FC           MOV     R4,A
   \   00012E   85F0..       MOV     ?V0 + 4,B
   \   000131   75F006       MOV     B,#0x6
   \   000134   E5..         MOV     A,?V0 + 1
   \   000136   A4           MUL     AB
   \   000137   25..         ADD     A,?V0 + 4
   \   000139   FD           MOV     R5,A
   \   00013A   74..         MOV     A,#aBlock & 0xff
   \   00013C   2C           ADD     A,R4
   \   00013D   FC           MOV     R4,A
   \   00013E   74..         MOV     A,#(aBlock >> 8) & 0xff
   \   000140   3D           ADDC    A,R5
   \   000141   FD           MOV     R5,A
   \   000142   8C82         MOV     DPL,R4
   \   000144   8D83         MOV     DPH,R5
   \   000146   A3           INC     DPTR
   \   000147   A3           INC     DPTR
   \   000148   EE           MOV     A,R6
   \   000149   F0           MOVX    @DPTR,A
   \   00014A   A3           INC     DPTR
   \   00014B   EF           MOV     A,R7
   \   00014C   F0           MOVX    @DPTR,A
    293              aBlock[hMemNew].Off   = Off;
   \   00014D   8C82         MOV     DPL,R4
   \   00014F   8D83         MOV     DPH,R5
   \   000151   E5..         MOV     A,?V0 + 2
   \   000153   F0           MOVX    @DPTR,A
   \   000154   A3           INC     DPTR
   \   000155   E5..         MOV     A,?V0 + 3
   \   000157   F0           MOVX    @DPTR,A
    294              if ((aBlock[hMemNew].Next  = Next) >0) {
   \   000158   EC           MOV     A,R4
   \   000159   2404         ADD     A,#0x4
   \   00015B   F582         MOV     DPL,A
   \   00015D   ED           MOV     A,R5
   \   00015E   3400         ADDC    A,#0x0
   \   000160   F583         MOV     DPH,A
   \   000162   E8           MOV     A,R0
   \   000163   F0           MOVX    @DPTR,A
   \   000164   6006         JZ      ??_Alloc_12
    295                aBlock[Next].Prev = hMemNew;  
   \   000166   12....       LCALL   ?Subroutine3 & 0xFFFF
    296              }
   \                     ??CrossCallReturnLabel_33:
   \   000169   E5..         MOV     A,?V0 + 0
   \   00016B   F0           MOVX    @DPTR,A
    297              aBlock[hMemNew].Prev  = hMemIns;
   \                     ??_Alloc_12:
   \   00016C   E5..         MOV     A,?V0 + 0
   \   00016E   75F006       MOV     B,#0x6
   \   000171   A4           MUL     AB
   \   000172   F8           MOV     R0,A
   \   000173   ACF0         MOV     R4,B
   \   000175   75F006       MOV     B,#0x6
   \   000178   E5..         MOV     A,?V0 + 1
   \   00017A   A4           MUL     AB
   \   00017B   2C           ADD     A,R4
   \   00017C   F9           MOV     R1,A
   \   00017D   12....       LCALL   ??Subroutine24_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000180   EA           MOV     A,R2
   \   000181   F0           MOVX    @DPTR,A
    298              aBlock[hMemIns].Next  = hMemNew;
   \   000182   75F006       MOV     B,#0x6
   \   000185   A4           MUL     AB
   \   000186   FA           MOV     R2,A
   \   000187   A8F0         MOV     R0,B
   \   000189   75F006       MOV     B,#0x6
   \   00018C   EB           MOV     A,R3
   \   00018D   A4           MUL     AB
   \   00018E   28           ADD     A,R0
   \   00018F   FB           MOV     R3,A
   \   000190   12....       LCALL   ?Subroutine15 & 0xFFFF
    299            }
   \                     ??CrossCallReturnLabel_17:
   \   000193   E5..         MOV     A,?V0 + 0
   \   000195   F0           MOVX    @DPTR,A
    300            /* Keep track of number of blocks and av. memory */
    301            GUI_ALLOC.NumUsedBlocks++;
   \   000196   90....       MOV     DPTR,#GUI_ALLOC
   \   000199   12....       LCALL   ?Subroutine11 & 0xFFFF
    302            GUI_ALLOC.NumFreeBlocks--;
   \                     ??CrossCallReturnLabel_11:
   \   00019C   A3           INC     DPTR
   \   00019D   12....       LCALL   ?Subroutine12 & 0xFFFF
    303            if (GUI_ALLOC.NumFreeBlocksMin > GUI_ALLOC.NumFreeBlocks) {
   \                     ??CrossCallReturnLabel_13:
   \   0001A0   90....       MOV     DPTR,#GUI_ALLOC + 4
   \   0001A3   12....       LCALL   ??Subroutine27_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   0001A6   7583..       MOV     DPH,#((GUI_ALLOC + 2) >> 8) & 0xff
   \   0001A9   7582..       MOV     DPL,#(GUI_ALLOC + 2) & 0xff
   \   0001AC   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   0001AF   5006         JNC     ??CrossCallReturnLabel_6
    304              GUI_ALLOC.NumFreeBlocksMin = GUI_ALLOC.NumFreeBlocks;
   \   0001B1   90....       MOV     DPTR,#GUI_ALLOC + 2
   \   0001B4   12....       LCALL   ?Subroutine8 & 0xFFFF
    305            }
    306            GUI_ALLOC.NumUsedBytes += size;
   \                     ??CrossCallReturnLabel_6:
   \   0001B7   90....       MOV     DPTR,#GUI_ALLOC + 6
   \   0001BA   E0           MOVX    A,@DPTR
   \   0001BB   2E           ADD     A,R6
   \   0001BC   F0           MOVX    @DPTR,A
   \   0001BD   A3           INC     DPTR
   \   0001BE   E0           MOVX    A,@DPTR
   \   0001BF   3F           ADDC    A,R7
   \   0001C0   F0           MOVX    @DPTR,A
    307            GUI_ALLOC.NumFreeBytes -= size;
   \   0001C1   A3           INC     DPTR
   \   0001C2   C3           CLR     C
   \   0001C3   E0           MOVX    A,@DPTR
   \   0001C4   9E           SUBB    A,R6
   \   0001C5   F0           MOVX    @DPTR,A
   \   0001C6   A3           INC     DPTR
   \   0001C7   E0           MOVX    A,@DPTR
   \   0001C8   9F           SUBB    A,R7
   \   0001C9   F0           MOVX    @DPTR,A
    308            if (GUI_ALLOC.NumFreeBytesMin > GUI_ALLOC.NumFreeBytes) {
   \   0001CA   90....       MOV     DPTR,#GUI_ALLOC + 10
   \   0001CD   12....       LCALL   ??Subroutine27_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   0001D0   7583..       MOV     DPH,#((GUI_ALLOC + 8) >> 8) & 0xff
   \   0001D3   7582..       MOV     DPL,#(GUI_ALLOC + 8) & 0xff
   \   0001D6   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   0001D9   5006         JNC     ??CrossCallReturnLabel_7
    309              GUI_ALLOC.NumFreeBytesMin = GUI_ALLOC.NumFreeBytes;
   \   0001DB   90....       MOV     DPTR,#GUI_ALLOC + 8
   \   0001DE   12....       LCALL   ?Subroutine8 & 0xFFFF
    310            }
    311            return hMemNew;
   \                     ??CrossCallReturnLabel_7:
   \   0001E1   AA..         MOV     R2,?V0 + 0
   \   0001E3   AB..         MOV     R3,?V0 + 1
   \                     ??_Alloc_2:
   \   0001E5   7F05         MOV     R7,#0x5
   \   0001E7   02....       LJMP    ?BANKED_LEAVE_XDATA
    312          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine26_0:
   \   000000   9F           SUBB    A,R7
   \   000001   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000003   65D0         XRL     A,PSW
   \   000005   33           RLC     A
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   C3           CLR     C
   \   000001   E0           MOVX    A,@DPTR
   \   000002   98           SUBB    A,R0
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   99           SUBB    A,R1
   \   000006   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000008   65D0         XRL     A,PSW
   \   00000A   33           RLC     A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   A3           INC     DPTR
   \   000006   E8           MOV     A,R0
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   E9           MOV     A,R1
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   74..         MOV     A,#aBlock & 0xff
   \   000002   28           ADD     A,R0
   \   000003   F8           MOV     R0,A
   \   000004   74..         MOV     A,#(aBlock >> 8) & 0xff
   \   000006   39           ADDC    A,R1
   \   000007   F9           MOV     R1,A
   \   000008   8882         MOV     DPL,R0
   \   00000A   8983         MOV     DPH,R1
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET
    313          
    314          /*********************************************************************
    315          *
    316          *       Exported routines
    317          *
    318          **********************************************************************
    319          */
    320          /*********************************************************************
    321          *
    322          *       GUI_ALLOC_Init
    323          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    324          void GUI_ALLOC_Init(void) {
   \                     GUI_ALLOC_Init:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    325            GUI_DEBUG_LOG("\nGUI_ALLOC_Init...");
    326            GUI_ALLOC.NumFreeBlocksMin = GUI_ALLOC.NumFreeBlocks = GUI_MAXBLOCKS-1;
   \   000004   90....       MOV     DPTR,#GUI_ALLOC + 2
   \   000007   7421         MOV     A,#0x21
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   A3           INC     DPTR
   \   00000B   E4           CLR     A
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   A3           INC     DPTR
   \   00000E   7421         MOV     A,#0x21
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   E4           CLR     A
   \   000013   F0           MOVX    @DPTR,A
    327            GUI_ALLOC.NumFreeBytesMin  = GUI_ALLOC.NumFreeBytes  = GUI_ALLOC_SIZE;
   \   000014   90....       MOV     DPTR,#GUI_ALLOC + 8
   \   000017   F0           MOVX    @DPTR,A
   \   000018   A3           INC     DPTR
   \   000019   7404         MOV     A,#0x4
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   E4           CLR     A
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   A3           INC     DPTR
   \   000020   7404         MOV     A,#0x4
   \   000022   F0           MOVX    @DPTR,A
    328            GUI_ALLOC.NumUsedBlocks = 0;
   \   000023   90....       MOV     DPTR,#GUI_ALLOC
   \   000026   E4           CLR     A
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   F0           MOVX    @DPTR,A
    329            GUI_ALLOC.NumUsedBytes = 0;
   \   00002A   90....       MOV     DPTR,#GUI_ALLOC + 6
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   F0           MOVX    @DPTR,A
    330            aBlock[0].Size = (1<<GUI_BLOCK_ALIGN);  /* occupy minimum for a block */
   \   000030   90....       MOV     DPTR,#aBlock + 2
   \   000033   7404         MOV     A,#0x4
   \   000035   F0           MOVX    @DPTR,A
   \   000036   A3           INC     DPTR
   \   000037   E4           CLR     A
   \   000038   F0           MOVX    @DPTR,A
    331            aBlock[0].Off  = 0;
   \   000039   90....       MOV     DPTR,#aBlock
   \   00003C   F0           MOVX    @DPTR,A
   \   00003D   A3           INC     DPTR
   \   00003E   F0           MOVX    @DPTR,A
    332            aBlock[0].Next = 0;
   \   00003F   90....       MOV     DPTR,#aBlock + 4
   \   000042   F0           MOVX    @DPTR,A
    333            IsInitialized =1;
   \   000043   90....       MOV     DPTR,#IsInitialized
   \   000046   04           INC     A
   \   000047   F0           MOVX    @DPTR,A
    334          }
   \   000048   80..         SJMP    ?Subroutine1
    335          
    336          /*********************************************************************
    337          *
    338          *       GUI_ALLOC_AllocNoInit
    339          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    340          GUI_HMEM GUI_ALLOC_AllocNoInit(GUI_ALLOC_DATATYPE Size) {
   \                     GUI_ALLOC_AllocNoInit:
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    341            GUI_HMEM hMem;
    342            if (Size == 0) {
   \   000005   EA           MOV     A,R2
   \   000006   4B           ORL     A,R3
   \   000007   7006         JNZ     ??GUI_ALLOC_AllocNoInit_0
    343              return (GUI_HMEM)0;
   \   000009   7A00         MOV     R2,#0x0
   \   00000B   7B00         MOV     R3,#0x0
   \   00000D   800D         SJMP    ??GUI_ALLOC_AllocNoInit_1
    344            }
    345            halIntState_t state;
    346            GUI_LOCK(state);
   \                     ??GUI_ALLOC_AllocNoInit_0:
   \   00000F   E5A8         MOV     A,0xa8
   \   000011   FE           MOV     R6,A
   \   000012   C2AF         CLR     0xa8.7
    347            GUI_DEBUG_LOG2("\nGUI_ALLOC_AllocNoInit... requesting %d, %d avail", Size, GUI_ALLOC.NumFreeBytes);
    348            hMem = _Alloc(Size);
   \   000014                ; Setup parameters for call to function _Alloc
   \   000014   12....       LCALL   ??_Alloc?relay
    349            GUI_DEBUG_LOG1("\nGUI_ALLOC_AllocNoInit : Handle", hMem);
    350            GUI_UNLOCK(state);
   \   000017   EE           MOV     A,R6
   \   000018   A2E7         MOV     C,0xE0 /* A   */.7
   \   00001A   92AF         MOV     0xa8.7,C
    351            return hMem;
   \                     ??GUI_ALLOC_AllocNoInit_1:
   \   00001C                REQUIRE ?Subroutine2
   \   00001C                REQUIRE _A_IEN0
   \   00001C                ; // Fall through to label ?Subroutine2
    352          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    353          
    354          /*********************************************************************
    355          *
    356          *       GUI_ALLOC_h2p
    357          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    358          void* GUI_ALLOC_h2p(GUI_HMEM  hMem) {
   \                     GUI_ALLOC_h2p:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    359            GUI_ASSERT_LOCK();
    360            #if GUI_DEBUG_LEVEL > 0
    361              if (!hMem) {
   \   000004   EA           MOV     A,R2
   \   000005   4B           ORL     A,R3
   \   000006   7006         JNZ     ??GUI_ALLOC_h2p_0
    362                GUI_DEBUG_ERROROUT("\n"__FILE__ " GUI_ALLOC_h2p: illegal argument (0 handle)");
    363                return 0;
   \   000008   7A00         MOV     R2,#0x0
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   8022         SJMP    ??GUI_ALLOC_h2p_1
    364              }
    365              if (aBlock[hMem].Size == 0) {
    366                GUI_DEBUG_ERROROUT("Dereferencing free block");
    367              }
    368          
    369            #endif
    370            return HMEM2PTR(hMem);
   \                     ??GUI_ALLOC_h2p_0:
   \   00000E   EA           MOV     A,R2
   \   00000F   75F006       MOV     B,#0x6
   \   000012   A4           MUL     AB
   \   000013   FA           MOV     R2,A
   \   000014   A8F0         MOV     R0,B
   \   000016   75F006       MOV     B,#0x6
   \   000019   EB           MOV     A,R3
   \   00001A   A4           MUL     AB
   \   00001B   28           ADD     A,R0
   \   00001C   FB           MOV     R3,A
   \   00001D   74..         MOV     A,#aBlock & 0xff
   \   00001F   2A           ADD     A,R2
   \   000020   F582         MOV     DPL,A
   \   000022   74..         MOV     A,#(aBlock >> 8) & 0xff
   \   000024   3B           ADDC    A,R3
   \   000025   F583         MOV     DPH,A
   \   000027   E0           MOVX    A,@DPTR
   \   000028   24..         ADD     A,#GUI_Heap & 0xff
   \   00002A   FA           MOV     R2,A
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   34..         ADDC    A,#(GUI_Heap >> 8) & 0xff
   \   00002F   FB           MOV     R3,A
   \                     ??GUI_ALLOC_h2p_1:
   \   000030                REQUIRE ?Subroutine1
   \   000030                ; // Fall through to label ?Subroutine1
    371          }
    372          
    373          /*********************************************************************
    374          *
    375          *       GUI_ALLOC_GetNumFreeBytes
    376          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    377          GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBytes(void) {
   \                     GUI_ALLOC_GetNumFreeBytes:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    378            _CheckInit();
   \   000004                ; Setup parameters for call to function _CheckInit
   \   000004   12....       LCALL   ??_CheckInit?relay
    379            return GUI_ALLOC.NumFreeBytes;  
   \   000007   90....       MOV     DPTR,#GUI_ALLOC + 8
   \   00000A   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   00000D   80..         SJMP    ?Subroutine1
    380          }
    381          
    382          /*********************************************************************
    383          *
    384          *       GUI_ALLOC_GetMaxSize
    385          *
    386          * Purpose:
    387          *   Returns the biggest available blocksize (without relocation).
    388          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006                REQUIRE ??Subroutine27_0
   \   000006                ; // Fall through to label ??Subroutine27_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    389          GUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize(void) {
   \                     GUI_ALLOC_GetMaxSize:
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    390            GUI_ALLOC_DATATYPE r = 0;
   \   000005   7E00         MOV     R6,#0x0
   \   000007   7F00         MOV     R7,#0x0
    391            GUI_ALLOC_DATATYPE NumFreeBytes;
    392            int i, iNext;
    393            halIntState_t state;
    394            GUI_LOCK(state);
   \   000009   A2AF         MOV     C,0xa8.7
   \   00000B   E4           CLR     A
   \   00000C   33           RLC     A
   \   00000D   F5..         MOV     ?V0 + 0,A
   \   00000F   C2AF         CLR     0xa8.7
    395            _CheckInit();
   \   000011                ; Setup parameters for call to function _CheckInit
   \   000011   12....       LCALL   ??_CheckInit?relay
    396            for (i=0; (iNext =aBlock[i].Next) !=0; i= iNext) {
   \   000014   7800         MOV     R0,#0x0
   \   000016   803F         SJMP    ??GUI_ALLOC_GetMaxSize_0
    397              NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
   \                     ??GUI_ALLOC_GetMaxSize_1:
   \   000018   E8           MOV     A,R0
   \   000019   75F006       MOV     B,#0x6
   \   00001C   A4           MUL     AB
   \   00001D   F8           MOV     R0,A
   \   00001E   EC           MOV     A,R4
   \   00001F   F9           MOV     R1,A
   \   000020   74..         MOV     A,#aBlock & 0xff
   \   000022   28           ADD     A,R0
   \   000023   F8           MOV     R0,A
   \   000024   74..         MOV     A,#(aBlock >> 8) & 0xff
   \   000026   39           ADDC    A,R1
   \   000027   F9           MOV     R1,A
   \   000028   EA           MOV     A,R2
   \   000029   75F006       MOV     B,#0x6
   \   00002C   A4           MUL     AB
   \   00002D   FC           MOV     R4,A
   \   00002E   85F0..       MOV     ?V0 + 1,B
   \   000031   AD..         MOV     R5,?V0 + 1
   \   000033   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000036   C082         PUSH    DPL
   \   000038   C083         PUSH    DPH
   \   00003A   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   00003D   D083         POP     DPH
   \   00003F   D082         POP     DPL
   \   000041   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000044   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000047   EC           MOV     A,R4
   \   000048   C3           CLR     C
   \   000049   98           SUBB    A,R0
   \   00004A   F8           MOV     R0,A
   \   00004B   ED           MOV     A,R5
   \   00004C   12....       LCALL   ?Subroutine17 & 0xFFFF
    398              if (NumFreeBytes > r) {
   \                     ??CrossCallReturnLabel_20:
   \   00004F   5004         JNC     ??GUI_ALLOC_GetMaxSize_2
    399                r = NumFreeBytes;
   \   000051   E8           MOV     A,R0
   \   000052   FE           MOV     R6,A
   \   000053   E9           MOV     A,R1
   \   000054   FF           MOV     R7,A
    400              }
    401            }
   \                     ??GUI_ALLOC_GetMaxSize_2:
   \   000055   EA           MOV     A,R2
   \   000056   F8           MOV     R0,A
   \                     ??GUI_ALLOC_GetMaxSize_0:
   \   000057   E8           MOV     A,R0
   \   000058   75F006       MOV     B,#0x6
   \   00005B   A4           MUL     AB
   \   00005C   FA           MOV     R2,A
   \   00005D   ACF0         MOV     R4,B
   \   00005F   EC           MOV     A,R4
   \   000060   FB           MOV     R3,A
   \   000061   12....       LCALL   ??Subroutine25_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000064   FA           MOV     R2,A
   \   000065   70B1         JNZ     ??GUI_ALLOC_GetMaxSize_1
    402            /* Check last block */
    403            NumFreeBytes = (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size));
   \   000067   E8           MOV     A,R0
   \   000068   75F006       MOV     B,#0x6
   \   00006B   A4           MUL     AB
   \   00006C   F8           MOV     R0,A
   \   00006D   A9F0         MOV     R1,B
   \   00006F   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000072   FA           MOV     R2,A
   \   000073   A3           INC     DPTR
   \   000074   E0           MOVX    A,@DPTR
   \   000075   FB           MOV     R3,A
   \   000076   E4           CLR     A
   \   000077   C3           CLR     C
   \   000078   9A           SUBB    A,R2
   \   000079   FA           MOV     R2,A
   \   00007A   7404         MOV     A,#0x4
   \   00007C   9B           SUBB    A,R3
   \   00007D   FB           MOV     R3,A
   \   00007E   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000081   EA           MOV     A,R2
   \   000082   C3           CLR     C
   \   000083   98           SUBB    A,R0
   \   000084   F8           MOV     R0,A
   \   000085   EB           MOV     A,R3
   \   000086   12....       LCALL   ?Subroutine17 & 0xFFFF
    404            if (NumFreeBytes > r) {
   \                     ??CrossCallReturnLabel_21:
   \   000089   5004         JNC     ??GUI_ALLOC_GetMaxSize_3
    405              r = NumFreeBytes;
   \   00008B   E8           MOV     A,R0
   \   00008C   FE           MOV     R6,A
   \   00008D   E9           MOV     A,R1
   \   00008E   FF           MOV     R7,A
    406            }
    407            GUI_UNLOCK(state);
   \                     ??GUI_ALLOC_GetMaxSize_3:
   \   00008F   E5..         MOV     A,?V0 + 0
   \   000091   A2E0         MOV     C,0xE0 /* A   */.0
   \   000093   92AF         MOV     0xa8.7,C
    408            return r;
   \   000095   EE           MOV     A,R6
   \   000096   FA           MOV     R2,A
   \   000097   EF           MOV     A,R7
   \   000098   FB           MOV     R3,A
   \   000099   02....       LJMP    ?Subroutine2 & 0xFFFF
   \   00009C                REQUIRE _A_IEN0
    409          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   99           SUBB    A,R1
   \   000001   F9           MOV     R1,A
   \   000002   C3           CLR     C
   \   000003   EE           MOV     A,R6
   \   000004   98           SUBB    A,R0
   \   000005   EF           MOV     A,R7
   \   000006   99           SUBB    A,R1
   \   000007   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000009   65D0         XRL     A,PSW
   \   00000B   33           RLC     A
   \   00000C   22           RET
    410          
    411          #else
    412          
    413          /*********************************************************************
    414          *
    415          *       External memory management functions
    416          *
    417          * The functions below will generate code only if the GUI memory
    418          * management is not used (GUI_ALLOC_ALLOC defined).
    419          *
    420          * Note:
    421          * The memory block allocated is bigger than the requested one, as we
    422          * store some add. information (size of the memory block) there.
    423          *
    424          **********************************************************************
    425          */
    426          
    427          typedef struct {
    428            union {
    429              GUI_ALLOC_DATATYPE Size;
    430              int Dummy;               /* Needed to guarantee alignment on 32 / 64 bit CPUs */
    431            } Info;      /* Unnamed would be best, but is not supported by all compilers */
    432          } INFO;
    433          
    434          /*********************************************************************
    435          *
    436          *       _GetSize
    437          */
    438          static GUI_ALLOC_DATATYPE _GetSize(GUI_HMEM  hMem) {
    439            INFO * pInfo;
    440            pInfo = (INFO *)GUI_ALLOC_H2P(hMem);
    441            return pInfo->Info.Size;
    442          }
    443          
    444          /*********************************************************************
    445          *
    446          *       _Free
    447          */
    448          static void _Free(GUI_HMEM  hMem) {
    449            GUI_ALLOC_FREE(hMem);
    450          }
    451          
    452          /*********************************************************************
    453          *
    454          *       GUI_ALLOC_AllocNoInit
    455          */
    456          GUI_HMEM GUI_ALLOC_AllocNoInit(GUI_ALLOC_DATATYPE Size) {
    457            GUI_HMEM hMem;
    458            if (Size == 0) {
    459              return (GUI_HMEM)0;
    460            }
    461            hMem= GUI_ALLOC_ALLOC(Size + sizeof(INFO));
    462            /* Init info structure */
    463            if (hMem) {
    464              INFO * pInfo;
    465              pInfo = (INFO *)GUI_ALLOC_H2P(hMem);
    466              pInfo->Info.Size = Size;
    467            }
    468            return hMem;
    469          }
    470          
    471          /*********************************************************************
    472          *
    473          *       GUI_ALLOC_h2p
    474          */
    475          void* GUI_ALLOC_h2p(GUI_HMEM  hMem) {
    476            U8* p = (U8*)GUI_ALLOC_H2P(hMem);    /* Pointer to memory block from memory manager */
    477            p += sizeof(INFO);                   /* Convert to pointer to usable area */
    478            return p;
    479          }
    480          
    481          /*********************************************************************
    482          *
    483          *       GUI_ALLOC_GetMaxSize
    484          */
    485          GUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize(void) {
    486            return GUI_ALLOC_GETMAXSIZE();
    487          }
    488          
    489          /*********************************************************************
    490          *
    491          *       GUI_ALLOC_Init
    492          */
    493          void GUI_ALLOC_Init(void) {
    494            #ifdef GUI_ALLOC_INIT
    495              GUI_ALLOC_INIT();
    496            #endif
    497          }
    498          
    499          #endif
    500          
    501          /*********************************************************************
    502          *
    503          *       Public code, common memory management functions
    504          *
    505          **********************************************************************
    506          */
    507          /*********************************************************************
    508          *
    509          *       GUI_ALLOC_GetSize
    510          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    511          GUI_ALLOC_DATATYPE GUI_ALLOC_GetSize(GUI_HMEM  hMem) {
   \                     GUI_ALLOC_GetSize:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    512            /* Do the error checking first */
    513            #if GUI_DEBUG_LEVEL>0
    514              if (!hMem) {
   \   000004   EA           MOV     A,R2
   \   000005   4B           ORL     A,R3
   \   000006   7006         JNZ     ??GUI_ALLOC_GetSize_0
    515                GUI_DEBUG_ERROROUT("\n"__FILE__ " GUI_ALLOC_h2p: illegal argument (0 handle)");
    516                return 0;
   \   000008   7A00         MOV     R2,#0x0
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   8014         SJMP    ??CrossCallReturnLabel_50
    517              }
    518            #endif
    519            return _GetSize(hMem);
   \                     ??GUI_ALLOC_GetSize_0:
   \   00000E   EA           MOV     A,R2
   \   00000F   75F006       MOV     B,#0x6
   \   000012   A4           MUL     AB
   \   000013   FA           MOV     R2,A
   \   000014   A8F0         MOV     R0,B
   \   000016   75F006       MOV     B,#0x6
   \   000019   EB           MOV     A,R3
   \   00001A   A4           MUL     AB
   \   00001B   28           ADD     A,R0
   \   00001C   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   00001F   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000022   02....       LJMP    ?Subroutine1 & 0xFFFF
    520          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   FB           MOV     R3,A
   \   000001   74..         MOV     A,#(aBlock + 2) & 0xff
   \   000003   2A           ADD     A,R2
   \   000004   F582         MOV     DPL,A
   \   000006   74..         MOV     A,#((aBlock + 2) >> 8) & 0xff
   \   000008   3B           ADDC    A,R3
   \   000009   F583         MOV     DPH,A
   \   00000B   22           RET
    521          
    522          /*********************************************************************
    523          *
    524          *       GUI_ALLOC_Free
    525          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    526          void GUI_ALLOC_Free(GUI_HMEM hMem) {
   \                     GUI_ALLOC_Free:
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    527            if (hMem == GUI_HMEM_NULL) { /* Note: This is not an error, it is permitted */
   \   000005   EA           MOV     A,R2
   \   000006   4B           ORL     A,R3
   \   000007   600D         JZ      ??GUI_ALLOC_Free_0
    528              return;
    529            }
    530            halIntState_t state;
    531            GUI_LOCK(state);
   \   000009   E5A8         MOV     A,0xa8
   \   00000B   FE           MOV     R6,A
   \   00000C   C2AF         CLR     0xa8.7
    532            GUI_DEBUG_LOG1("\nGUI_ALLOC_Free(%d)", hMem);
    533            _Free(hMem);
   \   00000E                ; Setup parameters for call to function _Free
   \   00000E   12....       LCALL   ??_Free?relay
    534            GUI_UNLOCK(state);
   \   000011   EE           MOV     A,R6
   \   000012   A2E7         MOV     C,0xE0 /* A   */.7
   \   000014   92AF         MOV     0xa8.7,C
    535          }
   \                     ??GUI_ALLOC_Free_0:
   \   000016   02....       LJMP    ?Subroutine0 & 0xFFFF
   \   000019                REQUIRE _A_IEN0
    536          
    537          
    538          /*********************************************************************
    539          *
    540          *       GUI_ALLOC_FreePtr
    541          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    542          void GUI_ALLOC_FreePtr(GUI_HMEM *ph) {
   \                     GUI_ALLOC_FreePtr:
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    543            halIntState_t state;
    544            GUI_LOCK(state);
   \   000009   E5A8         MOV     A,0xa8
   \   00000B   F5..         MOV     ?V0 + 0,A
   \   00000D   C2AF         CLR     0xa8.7
    545            GUI_ALLOC_Free(*ph);
   \   00000F                ; Setup parameters for call to function GUI_ALLOC_Free
   \   00000F   8E82         MOV     DPL,R6
   \   000011   8F83         MOV     DPH,R7
   \   000013   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   000016   12....       LCALL   ??GUI_ALLOC_Free?relay
    546            *ph =0;
   \   000019   8E82         MOV     DPL,R6
   \   00001B   8F83         MOV     DPH,R7
   \   00001D   E4           CLR     A
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   A3           INC     DPTR
   \   000020   F0           MOVX    @DPTR,A
    547            GUI_UNLOCK(state);
   \   000021   E5..         MOV     A,?V0 + 0
   \   000023   A2E7         MOV     C,0xE0 /* A   */.7
   \   000025   92AF         MOV     0xa8.7,C
    548          }
   \   000027   02....       LJMP    ?Subroutine0 & 0xFFFF
   \   00002A                REQUIRE _A_IEN0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   9E           SUBB    A,R6
   \   000001   EB           MOV     A,R3
   \   000002                REQUIRE ??Subroutine26_0
   \   000002                ; // Fall through to label ??Subroutine26_0

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??_Free?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    _Free

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??_CreateHole?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    _CreateHole

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??_CheckInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    _CheckInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??_Alloc?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    _Alloc

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GUI_ALLOC_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GUI_ALLOC_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GUI_ALLOC_AllocNoInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GUI_ALLOC_AllocNoInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GUI_ALLOC_h2p?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GUI_ALLOC_h2p

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GUI_ALLOC_GetNumFreeBytes?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GUI_ALLOC_GetNumFreeBytes

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GUI_ALLOC_GetMaxSize?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GUI_ALLOC_GetMaxSize

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GUI_ALLOC_GetSize?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GUI_ALLOC_GetSize

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GUI_ALLOC_Free?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GUI_ALLOC_Free

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GUI_ALLOC_FreePtr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GUI_ALLOC_FreePtr
    549          
    550          
    551          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function                  ISTACK PSTACK XSTACK
     --------                  ------ ------ ------
     GUI_ALLOC_AllocNoInit         0      0     10
       -> _Alloc                   0      0     20
     GUI_ALLOC_Free                0      0     18
       -> _Free                    0      0     18
     GUI_ALLOC_FreePtr             0      0      9
       -> GUI_ALLOC_Free           0      0     18
     GUI_ALLOC_GetMaxSize          2      0     10
       -> _CheckInit               0      0     20
     GUI_ALLOC_GetNumFreeBytes     2      0      0
       -> _CheckInit               4      0      0
     GUI_ALLOC_GetSize             2      0      0
     GUI_ALLOC_Init                2      0      0
     GUI_ALLOC_h2p                 2      0      0
     _Alloc                        2      0     23
       -> _CheckInit               0      0     26
       -> _CreateHole              0      0     26
     _CheckInit                    2      0     13
       -> GUI_ALLOC_Init           4      0      0
     _CreateHole                   2      0     31
       -> memmove                  0      0     36
     _Free                         1      0     18


   Segment part sizes:

     Function/Label                    Bytes
     --------------                    -----
     _A_IEN0                              1
     GUI_Heap                          1024
     aBlock                             204
     GUI_ALLOC                           12
     IsInitialized                        1
     _Free                              161
     ?Subroutine0                         5
     ?Subroutine22                        4
     ??Subroutine23_0                     6
     ?Subroutine3                         7
     ??Subroutine24_0                    11
     ?Subroutine15                        4
     ?Subroutine21                       11
     ?Subroutine12                       10
     ?Subroutine11                       10
     ??Subroutine27_0                     6
     _CreateHole                        266
     ?Subroutine18                       11
     ?Subroutine14                        8
     ??Subroutine25_0                     5
     ?Subroutine20                        9
     ?Subroutine6                        39
     ?Subroutine13                        9
     ?Subroutine5                        11
     ?Subroutine7                         6
     ??Subroutine28_0                     6
     _CheckInit                          16
     ?Subroutine1                         7
     _Alloc                             490
     ??Subroutine26_0                     7
     ?Subroutine10                       12
     ?Subroutine8                        12
     ?Subroutine4                        14
     GUI_ALLOC_Init                      74
     GUI_ALLOC_AllocNoInit               28
     ?Subroutine2                         5
     GUI_ALLOC_h2p                       48
     GUI_ALLOC_GetNumFreeBytes           15
     ?Subroutine9                         6
     GUI_ALLOC_GetMaxSize               156
     ?Subroutine17                       13
     GUI_ALLOC_GetSize                   37
     ?Subroutine16                       12
     GUI_ALLOC_Free                      25
     GUI_ALLOC_FreePtr                   42
     ?Subroutine19                        2
     ??_Free?relay                        6
     ??_CreateHole?relay                  6
     ??_CheckInit?relay                   6
     ??_Alloc?relay                       6
     ??GUI_ALLOC_Init?relay               6
     ??GUI_ALLOC_AllocNoInit?relay        6
     ??GUI_ALLOC_h2p?relay                6
     ??GUI_ALLOC_GetNumFreeBytes?relay    6
     ??GUI_ALLOC_GetMaxSize?relay         6
     ??GUI_ALLOC_GetSize?relay            6
     ??GUI_ALLOC_Free?relay               6
     ??GUI_ALLOC_FreePtr?relay            6

 
 1 626 bytes in segment BANKED_CODE
    72 bytes in segment BANK_RELAYS
     1 byte  in segment SFR_AN
 1 241 bytes in segment XDATA_Z
 
 1 698 bytes of CODE  memory
     0 bytes of DATA  memory (+ 1 byte shared)
 1 241 bytes of XDATA memory

Errors: none
Warnings: none

///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.10.1.10194/W32 for 8051        14/Jun/2016  16:18:33 /
// Copyright 2004-2011 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data_rom                                          /
//    Dptr setup         =  1,16                                              /
//    Source file        =  F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\W /
//                          SN-CSิดย๋\ZStack-CC2530-2.5.1a\Components\uCGUI\C /
//                          ore\GUICurs.c                                     /
//    Command line       =  -f F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย /
//                          ็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack /
//                          \Utilities\SerialApp\CC2530DB\..\..\..\Tools\CC25 /
//                          30DB\f8wCoord.cfg (-DCPU32MHZ -DROOT=__near_func  /
//                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                  /
//                          -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8        /
//                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)   /
//                          -f F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย /
//                          ็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack /
//                          \Utilities\SerialApp\CC2530DB\..\..\..\Tools\CC25 /
//                          30DB\f8wConfig.cfg (-DZIGBEEPRO -DSECURE=0        /
//                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                 /
//                          -DDEFAULT_CHANLIST=0x00000800                     /
//                          -DZDAPP_CONFIG_PAN_ID=0x1001                      /
//                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M /
//                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             /
//                          -DBEACON_REQ_DELAY_MASK=0x00FF                    /
//                          -DLINK_STATUS_JITTER_MASK=0x007F                  /
//                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P /
//                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           /
//                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3   /
//                          -DNWK_MAX_DATA_RETRIES=2                          /
//                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        /
//                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40          /
//                          -DNWK_MAX_BINDING_ENTRIES=4                       /
//                          -DMAX_BINDING_CLUSTER_IDS=4                       /
//                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     /
//                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   /
//                          0x0A, 0x0C, 0x0D}" -DMAC_MAX_FRAME_SIZE=116       /
//                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const    /
//                          __code" -DGENERIC=__generic                       /
//                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000       /
//                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)  /
//                          -DREJOIN_POLL_RATE=440 F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘น /
//                          โลฬืสมฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2. /
//                          5.1a\Components\uCGUI\Core\GUICurs.c -D           /
//                          HAL_UART=TRUE -D SERIAL_APP_PORT=0 -D COOR -D     /
//                          LCD_SUPPORTED -D NV_INIT -lC                      /
//                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\W /
//                          SN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Ut /
//                          ilities\SerialApp\CC2530DB\CoordinatorEB\List\    /
//                          -lA F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ /
//                          ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstac /
//                          k\Utilities\SerialApp\CC2530DB\CoordinatorEB\List /
//                          \ --diag_suppress Pe001,Pa010 -o                  /
//                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\W /
//                          SN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Ut /
//                          ilities\SerialApp\CC2530DB\CoordinatorEB\Obj\ -e  /
//                          --no_code_motion --debug --core=plain             /
//                          --dptr=16,1 --data_model=large                    /
//                          --code_model=banked --calling_convention=xdata_re /
//                          entrant --place_constants=data_rom                /
//                          --nr_virtual_regs 16 -I                           /
//                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\W /
//                          SN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Ut /
//                          ilities\SerialApp\CC2530DB\ -I                    /
//                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\W /
//                          SN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Ut /
//                          ilities\SerialApp\CC2530DB\..\Public\ -I          /
//                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\W /
//                          SN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Ut /
//                          ilities\SerialApp\CC2530DB\..\..\..\..\..\Compone /
//                          nts\uCGUI\Core\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬื /
//                          สมฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a /
//                          \Projects\zstack\Utilities\SerialApp\CC2530DB\..\ /
//                          ..\..\..\..\Components\uCGUI\MultiLayer\ -I       /
//                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\W /
//                          SN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Ut /
//                          ilities\SerialApp\CC2530DB\..\..\..\..\..\Compone /
//                          nts\uCGUI\Config\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโล /
//                          ฬืสมฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5. /
//                          1a\Projects\zstack\Utilities\SerialApp\CC2530DB\. /
//                          .\Coordinator\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืส /
//                          มฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\ /
//                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\. /
//                          .\..\ZMain\TI2530DB\ -I                           /
//                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\W /
//                          SN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Ut /
//                          ilities\SerialApp\CC2530DB\..\..\..\..\..\Compone /
//                          nts\hal\include\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬ /
//                          ืสมฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1 /
//                          a\Projects\zstack\Utilities\SerialApp\CC2530DB\.. /
//                          \..\..\..\..\Components\hal\target\CC2530EB\ -I   /
//                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\W /
//                          SN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Ut /
//                          ilities\SerialApp\CC2530DB\..\..\..\..\..\Compone /
//                          nts\mac\include\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬ /
//                          ืสมฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1 /
//                          a\Projects\zstack\Utilities\SerialApp\CC2530DB\.. /
//                          \..\..\..\..\Components\mac\high_level\ -I        /
//                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\W /
//                          SN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Ut /
//                          ilities\SerialApp\CC2530DB\..\..\..\..\..\Compone /
//                          nts\mac\low_level\srf04\ -I                       /
//                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\W /
//                          SN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Ut /
//                          ilities\SerialApp\CC2530DB\..\..\..\..\..\Compone /
//                          nts\mac\low_level\srf04\single_chip\ -I           /
//                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\W /
//                          SN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Ut /
//                          ilities\SerialApp\CC2530DB\..\..\..\..\..\Compone /
//                          nts\mt\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\Z /
//                          igBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Project /
//                          s\zstack\Utilities\SerialApp\CC2530DB\..\..\..\.. /
//                          \..\Components\osal\include\ -I                   /
//                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\W /
//                          SN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Ut /
//                          ilities\SerialApp\CC2530DB\..\..\..\..\..\Compone /
//                          nts\services\saddr\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘น /
//                          โลฬืสมฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2. /
//                          5.1a\Projects\zstack\Utilities\SerialApp\CC2530DB /
//                          \..\..\..\..\..\Components\services\sdata\ -I     /
//                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\W /
//                          SN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Ut /
//                          ilities\SerialApp\CC2530DB\..\..\..\..\..\Compone /
//                          nts\stack\af\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสม /
//                          ฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\P /
//                          rojects\zstack\Utilities\SerialApp\CC2530DB\..\.. /
//                          \..\..\..\Components\stack\nwk\ -I                /
//                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\W /
//                          SN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Ut /
//                          ilities\SerialApp\CC2530DB\..\..\..\..\..\Compone /
//                          nts\stack\sapi\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬื /
//                          สมฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a /
//                          \Projects\zstack\Utilities\SerialApp\CC2530DB\..\ /
//                          ..\..\..\..\Components\stack\sec\ -I              /
//                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\W /
//                          SN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Ut /
//                          ilities\SerialApp\CC2530DB\..\..\..\..\..\Compone /
//                          nts\stack\sys\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืส /
//                          มฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\ /
//                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\. /
//                          .\..\..\..\Components\stack\zdo\ -I               /
//                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\W /
//                          SN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Ut /
//                          ilities\SerialApp\CC2530DB\..\..\..\..\..\Compone /
//                          nts\zmac\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210 /
//                          \ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Proje /
//                          cts\zstack\Utilities\SerialApp\CC2530DB\..\..\..\ /
//                          ..\..\Components\zmac\f8w\ -Ohz                   /
//                          --require_prototypes                              /
//    List file          =  F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\W /
//                          SN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Ut /
//                          ilities\SerialApp\CC2530DB\CoordinatorEB\List\GUI /
//                          Curs.s51                                          /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME GUICurs

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?BDISPATCH
        EXTERN ?BRET

        PUBLIC ??GUICurs_C?relay
        FUNCTION ??GUICurs_C?relay,0203H
        PUBLIC GUICurs_C
        FUNCTION GUICurs_C,0203H
        ARGFRAME XSTACK, 0, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA_SP SP IDATA
        CFI StackFrame CFA_PSP16 PSP16 XDATA
        CFI StackFrame CFA_XSP16 XSP16 XDATA
        CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
        CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
        CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
        CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
        CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
        CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
        CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
        CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
        CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
        CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
        CFI VirtualResource ?RET:24
        CFI Resource ?BRET_EXT:8
        CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
        CFI ResourceParts PSP16 PSPH, PSPL
        CFI ResourceParts XSP16 XSPH, XSPL
        CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-3
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B Undefined
        CFI A Undefined
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 Undefined
        CFI R5 Undefined
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT Frame(CFA_SP, 3)
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon0
        
GUICurs_C           SYMBOL "GUICurs_C"
??GUICurs_C?relay   SYMBOL "?relay", GUICurs_C

// F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Components\uCGUI\Core\GUICurs.c
//    1 /*
//    2 *********************************************************************************************************
//    3 *                                                uC/GUI
//    4 *                        Universal graphic software for embedded applications
//    5 *
//    6 *                       (c) Copyright 2002, Micrium Inc., Weston, FL
//    7 *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
//    8 *
//    9 *              ตC/GUI is protected by international copyright laws. Knowledge of the
//   10 *              source code may not be used to write a similar product. This file may
//   11 *              only be used in accordance with a license and should not be redistributed
//   12 *              in any way. We appreciate your understanding and fairness.
//   13 *
//   14 ----------------------------------------------------------------------
//   15 File        : GUICurs.C
//   16 Purpose     : Cursor routines of the graphics library
//   17 ---------------------------END-OF-HEADER------------------------------
//   18 */
//   19 
//   20 #include <stddef.h>           /* needed for definition of NULL */
//   21 #include "GUI_Private.h"
//   22 
//   23 #if GUI_SUPPORT_CURSOR
//   24 
//   25 /*********************************************************************
//   26 *
//   27 *       static data
//   28 *
//   29 **********************************************************************
//   30 */
//   31 
//   32 static GUI_HMEM          _hBuffer;
//   33 static GUI_RECT          _Rect;
//   34 static char              _CursorIsVis;        /* Currently visible ? */
//   35 static char              _CursorOn;
//   36 static const GUI_CURSOR GUI_UNI_PTR * _pCursor;
//   37 static U8                _CursorDeActCnt;
//   38 static int               _AllocSize;
//   39 static int               _x, _y;              /* Position of hot spot */
//   40 static GUI_RECT          _ClipRect;
//   41 static LCD_PIXELINDEX    _ColorIndex[4];      /* Color-Cache */
//   42 
//   43 /*********************************************************************
//   44 *
//   45 *       static code, helper functions
//   46 *
//   47 **********************************************************************
//   48 */
//   49 /*********************************************************************
//   50 *
//   51 *       _SetPixelIndex
//   52 *
//   53 * Purpose
//   54 *   Sets the pixel index for the Cursor.
//   55 *   Note the following:
//   56 *   - We do the clipping in this routine
//   57 *   - We do NOT call the driver directly, but thru its API table.
//   58 *     This allows others (e.g. the VNC server) to be in the loop-
//   59 */
//   60 static void _SetPixelIndex(int x, int y, int Index) {
//   61   if ((y >= _ClipRect.y0) && (y <= _ClipRect.y1)) {
//   62     if ((x >= _ClipRect.x0) && (x <= _ClipRect.x1)) {
//   63       LCD_aAPI[0]->pfSetPixelIndex(x, y, Index);
//   64     }
//   65   }
//   66 }
//   67 
//   68 /*********************************************************************
//   69 *
//   70 *       _GetPixelIndex
//   71 *
//   72 * Purpose
//   73 *   Gets a pixel index for the Cursor.
//   74 */
//   75 static int _GetPixelIndex(int x, int y) {
//   76   if ((y >= _ClipRect.y0) && (y <= _ClipRect.y1)) {
//   77     if ((x >= _ClipRect.x0) && (x <= _ClipRect.x1)) {
//   78       return LCD_L0_GetPixelIndex(x, y);
//   79     }
//   80   }
//   81   return 0;
//   82 }
//   83 
//   84 /*********************************************************************
//   85 *
//   86 *       _Undraw
//   87 *
//   88 * Purpose
//   89 *   Remove the cursors
//   90 */
//   91 static void _Undraw(void) {
//   92   int x, y, xSize, ySize;
//   93   LCD_PIXELINDEX* pData;
//   94   /* Save bitmap data */
//   95   GUI_LOCK();
//   96   if (_hBuffer) {
//   97     pData = (LCD_PIXELINDEX*)GUI_ALLOC_h2p(_hBuffer);
//   98     xSize = _Rect.x1 - _Rect.x0 + 1;
//   99     ySize = _Rect.y1 - _Rect.y0 + 1;
//  100     for (y = 0; y < ySize; y++) {
//  101       for (x = 0; x < xSize; x++) {
//  102         _SetPixelIndex(x + _Rect.x0, y + _Rect.y0, *(pData + x));
//  103       }
//  104       pData += _pCursor->pBitmap->XSize;
//  105     }
//  106   }
//  107   GUI_UNLOCK();
//  108 }
//  109 
//  110 /*********************************************************************
//  111 *
//  112 *       _Log2Phys
//  113 */
//  114 static int _Log2Phys(int Index) {
//  115   if (Index < 4) {
//  116     return _ColorIndex[Index];
//  117   } else {
//  118     LCD_COLOR Color = *(_pCursor->pBitmap->pPal->pPalEntries + Index);
//  119     return LCD_Color2Index(Color);
//  120   }
//  121 }
//  122 
//  123 /*********************************************************************
//  124 *
//  125 *       _Draw
//  126 */
//  127 static void _Draw(void) {
//  128   int x, y, xSize, ySize;
//  129   LCD_PIXELINDEX* pData;
//  130   const GUI_BITMAP GUI_UNI_PTR * pBM;
//  131   GUI_LOCK();
//  132   if (_hBuffer) {
//  133     /* Save bitmap data */
//  134     pBM = _pCursor->pBitmap;
//  135     pData = (LCD_PIXELINDEX*)GUI_ALLOC_h2p(_hBuffer);
//  136     xSize = _Rect.x1 - _Rect.x0 + 1;
//  137     ySize = _Rect.y1 - _Rect.y0 + 1;
//  138     for (y = 0; y < ySize; y++) {
//  139       for (x = 0; x < xSize; x++) {
//  140         int BitmapPixel;
//  141         *(pData + x) = _GetPixelIndex(_Rect.x0 + x, _Rect.y0 + y);
//  142         BitmapPixel = GUI_GetBitmapPixelIndex(pBM, x, y);
//  143         if (BitmapPixel) {
//  144           _SetPixelIndex(_Rect.x0 + x, _Rect.y0 + y, _Log2Phys(BitmapPixel));
//  145         }
//  146       }
//  147       pData += pBM->XSize;
//  148     }
//  149   }
//  150   GUI_UNLOCK();
//  151 }
//  152 
//  153 /*********************************************************************
//  154 *
//  155 *       _CalcRect
//  156 */
//  157 static void _CalcRect(void) {
//  158   if (_pCursor) {
//  159     _Rect.x0 = _x - _pCursor->xHot;
//  160     _Rect.y0 = _y - _pCursor->yHot;
//  161     _Rect.x1 = _Rect.x0 + _pCursor->pBitmap->XSize - 1;
//  162     _Rect.y1 = _Rect.y0 + _pCursor->pBitmap->YSize - 1;
//  163   }
//  164 }
//  165 
//  166 /*********************************************************************
//  167 *
//  168 *       _Hide
//  169 */
//  170 static void _Hide(void) {
//  171   if (_CursorIsVis) {
//  172     _Undraw();
//  173     _CursorIsVis = 0;
//  174   }
//  175 }
//  176 
//  177 /*********************************************************************
//  178 *
//  179 *       _Show
//  180 */
//  181 static void _Show(void) {
//  182   if (_CursorOn && (_CursorDeActCnt==0)) {
//  183     _CursorIsVis = 1;
//  184     _Draw();  
//  185   }
//  186 }
//  187 
//  188 /*********************************************************************
//  189 *
//  190 *       _TempHide
//  191 *
//  192 * Purpose:
//  193 *   Hide cursor if a part of the given rectangle is located in the
//  194 *   rectangle used for the cursor. This routine is called automatically
//  195 *   by the window manager. This way the window manager can
//  196 *   automatically make sure that the cursor is always displayed
//  197 *   correctly.
//  198 *
//  199 * Params:
//  200 *   pRect   Rectangle under consideration
//  201 *
//  202 * Return value:
//  203 *   0:      No action taken
//  204 *           Cursor was not visible or not affected because rectangles
//  205 *           did not overlap
//  206 *   1:      Cursor hidden -> WM needs to restore cursor after
//  207 *           drawing operation
//  208 */
//  209 static char _TempHide(const GUI_RECT* pRect) {
//  210   if (!_CursorIsVis) {
//  211     return 0;             /* Cursor not visible -> nothing to do */
//  212   }
//  213   if ((pRect == NULL) || GUI_RectsIntersect(pRect, &_Rect)) {
//  214     _Hide();              /* Cursor needs to be hidden */
//  215     return 1;
//  216   }
//  217   return 0;               /* Cursor not affected -> nothing to do */
//  218 }
//  219 
//  220 /*********************************************************************
//  221 *
//  222 *       _TempUnhide
//  223 */
//  224 static void _TempUnhide(void) {
//  225   _Show();
//  226 }
//  227 
//  228 /*********************************************************************
//  229 *
//  230 *       Public code
//  231 *
//  232 **********************************************************************
//  233 */
//  234 /*********************************************************************
//  235 *
//  236 *       GUI_CURSOR_Activate
//  237 */
//  238 void GUI_CURSOR_Activate(void) {
//  239   GUI_LOCK();
//  240   if ((--_CursorDeActCnt) ==0) {
//  241     _Show();
//  242   }
//  243   GUI_UNLOCK();
//  244 }
//  245 
//  246 /*********************************************************************
//  247 *
//  248 *       GUI_CURSOR_Deactivate
//  249 */
//  250 void GUI_CURSOR_Deactivate(void) {
//  251   GUI_LOCK();
//  252   if (_CursorDeActCnt++ ==0)
//  253     _Hide();
//  254   GUI_UNLOCK();
//  255 }
//  256 
//  257 /*********************************************************************
//  258 *
//  259 *       GUI_CURSOR_Select
//  260 */
//  261 const GUI_CURSOR GUI_UNI_PTR * GUI_CURSOR_Select(const GUI_CURSOR GUI_UNI_PTR * pCursor) {
//  262   int AllocSize;
//  263   const GUI_BITMAP GUI_UNI_PTR * pBM;
//  264   const GUI_CURSOR GUI_UNI_PTR * pOldCursor;
//  265   GUI_LOCK();
//  266   pOldCursor = _pCursor;
//  267   if (pCursor != _pCursor) {
//  268     int i;
//  269     pBM = pCursor->pBitmap;
//  270     i = pBM->pPal->NumEntries > 4 ? 4 : pBM->pPal->NumEntries;
//  271     while (i--) {
//  272       LCD_COLOR Color = *(pBM->pPal->pPalEntries + i);
//  273       _ColorIndex[i] = LCD_Color2Index(Color);
//  274     }
//  275     _Hide();
//  276     AllocSize = pBM->XSize * pBM->YSize * sizeof(LCD_PIXELINDEX);
//  277     if (AllocSize != _AllocSize) {
//  278       GUI_ALLOC_Free(_hBuffer);
//  279       _hBuffer = 0;
//  280     }
//  281     _hBuffer = GUI_ALLOC_AllocZero(AllocSize);
//  282     _CursorOn = 1;
//  283     _pCursor = pCursor;
//  284     _CalcRect();
//  285     _Show();
//  286   }
//  287   GUI_UNLOCK();
//  288   return pOldCursor;
//  289 }
//  290 
//  291 /*********************************************************************
//  292 *
//  293 *       GUI_CURSOR_Hide
//  294 */
//  295 void GUI_CURSOR_Hide(void) {
//  296   GUI_LOCK();
//  297   _Hide();
//  298   _CursorOn = 0;
//  299   /* Set function pointer which window manager can use */
//  300   GUI_CURSOR_pfTempHide   = NULL;
//  301   GUI_CURSOR_pfTempUnhide = NULL;
//  302   GUI_UNLOCK();
//  303 }
//  304 
//  305 /*********************************************************************
//  306 *
//  307 *       GUI_CURSOR_Show
//  308 */
//  309 void GUI_CURSOR_Show(void) {
//  310   GUI_LOCK();
//  311   LCDDEV_L0_GetRect(&_ClipRect);
//  312   _Hide();
//  313   _CursorOn = 1;
//  314   /* Set function pointer which window manager can use */
//  315   GUI_CURSOR_pfTempHide   = _TempHide;
//  316   GUI_CURSOR_pfTempUnhide = _TempUnhide;
//  317   if (!_pCursor) {
//  318     GUI_CURSOR_Select(GUI_DEFAULT_CURSOR);
//  319   } else {
//  320     _Show();
//  321   }
//  322   GUI_UNLOCK();
//  323 }
//  324 
//  325 /*********************************************************************
//  326 *
//  327 *       GUI_CURSOR_SetPosition
//  328 */
//  329 void GUI_CURSOR_SetPosition(int xNewPos, int yNewPos) {
//  330   int x, xStart, xStep, xEnd, xOff, xOverlapMin, xOverlapMax;
//  331   int y, yStart, yStep, yEnd, yOff, yOverlapMin, yOverlapMax;
//  332   int xSize;
//  333   LCD_PIXELINDEX* pData;
//  334   GUI_LOCK();
//  335   if (_hBuffer) {
//  336     if ((_x != xNewPos) | (_y != yNewPos)) {
//  337       if (_CursorOn) {
//  338         const GUI_BITMAP GUI_UNI_PTR * pBM = _pCursor->pBitmap;
//  339         /* Save & set clip rect */
//  340         /* Compute helper variables */
//  341         pData = (LCD_PIXELINDEX*)GUI_ALLOC_h2p(_hBuffer);
//  342         xSize = _pCursor->pBitmap->XSize;
//  343         xOff = xNewPos - _x;
//  344         if (xOff > 0) {
//  345           xStep  = 1;
//  346           xStart = 0;
//  347           xEnd   = _pCursor->pBitmap->XSize;
//  348           xOverlapMax = xEnd -1;
//  349           xOverlapMin = xOff;
//  350         } else {
//  351           xStep  = -1;
//  352           xStart = xSize - 1;
//  353           xEnd   = -1;
//  354           xOverlapMin = 0;
//  355           xOverlapMax = xStart + xOff;
//  356         }
//  357         yOff = yNewPos - _y;
//  358         if (yOff > 0) {
//  359           yStep  = 1;
//  360           yStart = 0;
//  361           yEnd   = _pCursor->pBitmap->YSize;
//  362           yOverlapMax = yEnd -1;
//  363           yOverlapMin = yOff;
//  364         } else {
//  365           yStep  = -1;
//  366           yStart = _pCursor->pBitmap->YSize - 1;
//  367           yEnd   = -1;
//  368           yOverlapMin = 0;
//  369           yOverlapMax = yStart + yOff;
//  370         }
//  371         /* Restore & Draw */
//  372         for (y = yStart; y != yEnd; y += yStep) {
//  373           char yOverlaps;
//  374           char yNewOverlaps;
//  375           int yNew = y + yOff;
//  376           yOverlaps    = (y >= yOverlapMin) && (y <= yOverlapMax);
//  377           yNewOverlaps = (yNew >= yOverlapMin) && (yNew <= yOverlapMax);
//  378           for (x= xStart; x != xEnd; x += xStep) {
//  379             char xyOverlaps, xyNewOverlaps;
//  380             int BitmapPixel;
//  381             LCD_PIXELINDEX Pixel;
//  382             LCD_PIXELINDEX* pSave = pData + x + y * xSize;
//  383             int xNew = x + xOff;
//  384             BitmapPixel = GUI_GetBitmapPixelIndex(pBM, x, y);
//  385             xyOverlaps    = (x    >= xOverlapMin) && (x    <= xOverlapMax) && yOverlaps;
//  386             xyNewOverlaps = (xNew >= xOverlapMin) && (xNew <= xOverlapMax) && yNewOverlaps;
//  387             /* Restore old pixel if it was not transparent */
//  388             if (BitmapPixel) {
//  389               if (!xyOverlaps || (GUI_GetBitmapPixelIndex(pBM, x - xOff, y - yOff) == 0)) {
//  390                 _SetPixelIndex(x + _Rect.x0, y + _Rect.y0, *(pSave));
//  391               }
//  392             }
//  393             /* Save */
//  394             if (xyNewOverlaps) {
//  395               Pixel = *(pData + xNew + yNew * xSize);
//  396             } else {
//  397               Pixel = _GetPixelIndex(_Rect.x0 + xNew, _Rect.y0 + yNew);
//  398             }
//  399             *pSave = Pixel;
//  400             /* Write new  ... We could write pixel by pixel here */
//  401             if (BitmapPixel) {
//  402               LCD_PIXELINDEX NewPixel = _Log2Phys(BitmapPixel);
//  403               _SetPixelIndex(_Rect.x0 + xNew, _Rect.y0 + yNew, NewPixel);
//  404             }
//  405           }
//  406         }
//  407       }
//  408       _x = xNewPos;
//  409       _y = yNewPos;
//  410       _CalcRect();
//  411     }
//  412   }
//  413   GUI_UNLOCK();
//  414 }
//  415 
//  416 #else
//  417 
//  418 void GUICurs_C(void);

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  419 void GUICurs_C(void) {} /* avoid empty object files */
GUICurs_C:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function GUICurs_C
        CODE
        ; Saved register size: 0
        ; Auto size: 0
        LJMP    ?BRET
        CFI EndBlock cfiBlock0

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??GUICurs_C?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    GUICurs_C

        END
//  420 
//  421 #endif   /* GUI_SUPPORT_CURSOR */
//  422 
//  423 /*************************** End of file ****************************/
// 
// 3 bytes in segment BANKED_CODE
// 6 bytes in segment BANK_RELAYS
// 
// 9 bytes of CODE memory
//
//Errors: none
//Warnings: none

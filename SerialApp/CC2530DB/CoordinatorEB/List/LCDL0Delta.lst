###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.10194/W32 for 8051         14/Jun/2016  16:18:53 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Components\uCGUI\Cor #
#                          e\LCDL0Delta.c                                     #
#    Command line       =  -f F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็ #
#                          \WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\U #
#                          tilities\SerialApp\CC2530DB\..\..\..\Tools\CC2530D #
#                          B\f8wCoord.cfg (-DCPU32MHZ -DROOT=__near_func      #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8         #
#                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)    #
#                          -f F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็ #
#                          \WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\U #
#                          tilities\SerialApp\CC2530DB\..\..\..\Tools\CC2530D #
#                          B\f8wConfig.cfg (-DZIGBEEPRO -DSECURE=0            #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0x1001                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโ #
#                          ลฬืสมฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5. #
#                          1a\Components\uCGUI\Core\LCDL0Delta.c -D           #
#                          HAL_UART=TRUE -D SERIAL_APP_PORT=0 -D COOR -D      #
#                          LCD_SUPPORTED -D NV_INIT -lC                       #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\CoordinatorEB\List\ -lA   #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\CoordinatorEB\List\       #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\CoordinatorEB\Obj\ -e     #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็ #
#                          \WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\U #
#                          tilities\SerialApp\CC2530DB\ -I                    #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\Public\ -I             #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \uCGUI\Core\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ2 #
#                          10\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Proj #
#                          ects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\ #
#                          ..\..\Components\uCGUI\MultiLayer\ -I              #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \uCGUI\Config\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสม #
#                          ฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Pr #
#                          ojects\zstack\Utilities\SerialApp\CC2530DB\..\Coor #
#                          dinator\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\Z #
#                          igBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects #
#                          \zstack\Utilities\SerialApp\CC2530DB\..\..\..\ZMai #
#                          n\TI2530DB\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ21 #
#                          0\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Proje #
#                          cts\zstack\Utilities\SerialApp\CC2530DB\..\..\..\. #
#                          .\..\Components\hal\include\ -I                    #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \hal\target\CC2530EB\ -I                           #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \mac\include\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ #
#                          210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Pro #
#                          jects\zstack\Utilities\SerialApp\CC2530DB\..\..\.. #
#                          \..\..\Components\mac\high_level\ -I               #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \mac\low_level\srf04\ -I                           #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \mac\low_level\srf04\single_chip\ -I               #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \mt\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBe #
#                          eอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zst #
#                          ack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\Co #
#                          mponents\osal\include\ -I                          #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \services\saddr\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬื #
#                          สมฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\Components\services\sdata\ -I            #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \stack\af\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210 #
#                          \ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projec #
#                          ts\zstack\Utilities\SerialApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\nwk\ -I                       #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \stack\sapi\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ2 #
#                          10\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Proj #
#                          ects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\ #
#                          ..\..\Components\stack\sec\ -I                     #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \stack\sys\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ21 #
#                          0\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Proje #
#                          cts\zstack\Utilities\SerialApp\CC2530DB\..\..\..\. #
#                          .\..\Components\stack\zdo\ -I                      #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \zmac\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\Zig #
#                          Beeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\z #
#                          stack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\ #
#                          Components\zmac\f8w\ -Ohz --require_prototypes     #
#    List file          =  F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\CoordinatorEB\List\LCDL0D #
#                          elta.lst                                           #
#    Object file        =  F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\CoordinatorEB\Obj\LCDL0De #
#                          lta.r51                                            #
#                                                                             #
#                                                                             #
###############################################################################

F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Components\uCGUI\Core\LCDL0Delta.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              ตC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : LCDL0Delta.c
     16          Purpose     : Link between GUI and LCD_L0... if delta display needs to
     17                        be supported
     18          ---------------------------END-OF-HEADER------------------------------
     19          */
     20          
     21          #include <stddef.h>             /* needed for definition of NULL */
     22          #include "GUI_Private.h"
     23          #include "GUIDebug.h"
     24          #include "LCD_Private.h"        /* private modul definitions & config */
     25          
     26          #if LCD_DELTA_MODE
     27          
     28          /*********************************************************************
     29          *
     30          *       Static data
     31          *
     32          **********************************************************************
     33          */
     34          static       U8             _aPixelData_0[LCD_XSIZE];
     35          static       U8             _aPixelData_1[LCD_XSIZE];
     36          static const GUI_LOGPALETTE _Pal;
     37          static       GUI_BITMAP     _Bm;
     38          static       int            _y;
     39          static       U8             _aRGB[3];
     40          
     41          /*********************************************************************
     42          *
     43          *       Static code
     44          *
     45          **********************************************************************
     46          */
     47          /*********************************************************************
     48          *
     49          *       _SetRGB
     50          */
     51          static void _SetRGB(LCD_PIXELINDEX ColorIndex) {
     52            _aRGB[0] = ColorIndex & 0x00f;
     53            _aRGB[1] = (ColorIndex & 0x0f0) >> 4;
     54            _aRGB[2] = (ColorIndex & 0xf00) >> 8;
     55          }
     56          
     57          /*********************************************************************
     58          *
     59          *       _SetPixel
     60          */
     61          static void _SetPixelIndex(int x, LCD_PIXELINDEX ColorIndex) {
     62            _SetRGB(ColorIndex);
     63            _aPixelData_0[x] = _aRGB[(x + (_y & 1)) % 3];
     64          }
     65          
     66          /*********************************************************************
     67          *
     68          *       _InitBM
     69          */
     70          static void _InitBM(int xsize, int x0) {
     71            _Bm.XSize        = xsize;
     72            _Bm.YSize        = 1;
     73            _Bm.BytesPerLine = xsize;
     74            _Bm.BitsPerPixel = 8;
     75            _Bm.pfDraw       = 0;
     76            _Bm.pData        = &_aPixelData_0[x0];
     77            _Bm.pPal         = &_Pal;
     78            _Bm.pfDraw       = 0;
     79          }
     80          
     81          /*********************************************************************
     82          *
     83          *       _DrawBitLine1BPP
     84          */
     85          static void _DrawBitLine1BPP(int x, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
     86            int xx;
     87            LCD_PIXELINDEX Index0 = *(pTrans+0);
     88            LCD_PIXELINDEX Index1 = *(pTrans+1);
     89            x += Diff;
     90            xx = x;
     91            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
     92            case 0:
     93              do {
     94                _SetPixelIndex(xx++, (*p & (0x80 >> Diff)) ? Index1 : Index0);
     95          			if (++Diff == 8) {
     96                  Diff = 0;
     97          				p++;
     98          			}
     99          		} while (--xsize);
    100              break;
    101            case LCD_DRAWMODE_TRANS:
    102              do {
    103            		if (*p & (0x80 >> Diff)) {
    104                  _SetPixelIndex(xx, Index1);
    105                } else {
    106                  _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
    107                }
    108                xx++;
    109          			if (++Diff == 8) {
    110                  Diff = 0;
    111          				p++;
    112          			}
    113          		} while (--xsize);
    114              break;
    115            case LCD_DRAWMODE_XOR:;
    116              do {
    117            		if (*p & (0x80 >> Diff)) {
    118                  int Pixel = LCD_L0_GetPixelIndex(xx, _y);
    119                  _SetPixelIndex(xx, LCD_NUM_COLORS - 1 - Pixel);
    120                }
    121                xx++;
    122          			if (++Diff == 8) {
    123                  Diff = 0;
    124          				p++;
    125          			}
    126          		} while (--xsize);
    127              break;
    128          	}
    129            LCD_L0_DrawBitmap(x, _y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, _Bm.pData, 0, 0);
    130          }
    131          
    132          /*********************************************************************
    133          *
    134          *       _DrawBitLine2BPP
    135          */
    136          static void _DrawBitLine2BPP(int x, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
    137            int xx;
    138            LCD_PIXELINDEX Pixels = *p;
    139            int CurrentPixel = Diff;
    140            x += Diff;
    141            xx = x;
    142            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
    143            case 0:
    144              if (pTrans) {
    145                do {
    146                  int Shift = (3 - CurrentPixel) << 1;
    147                  int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    148                  LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
    149                  _SetPixelIndex(xx++, PixelIndex);
    150                  if (++CurrentPixel == 4) {
    151                    CurrentPixel = 0;
    152                    Pixels = *(++p);
    153                  }
    154          		  } while (--xsize);
    155              } else {
    156                do {
    157                  int Shift = (3 - CurrentPixel) << 1;
    158                  int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    159                  _SetPixelIndex(xx++, Index);
    160                  if (++CurrentPixel == 4) {
    161                    CurrentPixel = 0;
    162                    Pixels = *(++p);
    163                  }
    164          		  } while (--xsize);
    165              }
    166              break;
    167            case LCD_DRAWMODE_TRANS:
    168              if (pTrans) {
    169                do {
    170                  int Shift = (3 - CurrentPixel) << 1;
    171                  int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    172                  if (Index) {
    173                    LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
    174                    _SetPixelIndex(xx, PixelIndex);
    175                  } else {
    176                    _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
    177                  }
    178                  xx++;
    179                  if (++CurrentPixel == 4) {
    180                    CurrentPixel = 0;
    181                    Pixels = *(++p);
    182                  }
    183          		  } while (--xsize);
    184              } else {
    185                do {
    186                  int Shift = (3 - CurrentPixel) << 1;
    187                  int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    188                  if (Index) {
    189                    _SetPixelIndex(xx, Index);
    190                  } else {
    191                    _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
    192                  }
    193                  xx++;
    194                  if (++CurrentPixel == 4) {
    195                    CurrentPixel = 0;
    196                    Pixels = *(++p);
    197                  }
    198          		  } while (--xsize);
    199              }
    200              break;
    201            }
    202            LCD_L0_DrawBitmap(x, _y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, _Bm.pData, 0, 0);
    203          }
    204          
    205          /*********************************************************************
    206          *
    207          *       _DrawBitLine4BPP
    208          */
    209          static void _DrawBitLine4BPP(int x, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
    210            int xx;
    211            U8 Pixels = *p;
    212            int CurrentPixel = Diff;
    213            x += Diff;
    214            xx = x;
    215            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
    216            case 0:
    217              if (pTrans) {
    218                do {
    219                  int Shift = (1 - CurrentPixel) << 2;
    220                  int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    221                  LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
    222                  _SetPixelIndex(xx++, PixelIndex);
    223                  if (++CurrentPixel == 2) {
    224                    CurrentPixel = 0;
    225                    Pixels = *(++p);
    226                  }
    227          		  } while (--xsize);
    228              } else {
    229                do {
    230                  int Shift = (1 - CurrentPixel) << 2;
    231                  int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    232                  _SetPixelIndex(xx++, Index);
    233                  if (++CurrentPixel == 2) {
    234                    CurrentPixel = 0;
    235                    Pixels = *(++p);
    236                  }
    237          		  } while (--xsize);
    238              }
    239              break;
    240            case LCD_DRAWMODE_TRANS:
    241              if (pTrans) {
    242                do {
    243                  int Shift = (1 - CurrentPixel) << 2;
    244                  int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    245                  if (Index) {
    246                    U8 PixelIndex = *(pTrans + Index);
    247                    _SetPixelIndex(xx, PixelIndex);
    248                  } else {
    249                    _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
    250                  }
    251                  xx++;
    252                  if (++CurrentPixel == 2) {
    253                    CurrentPixel = 0;
    254                    Pixels = *(++p);
    255                  }
    256          		  } while (--xsize);
    257              } else {
    258                do {
    259                  int Shift = (1 - CurrentPixel) << 2;
    260                  int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    261                  if (Index) {
    262                    _SetPixelIndex(xx, Index);
    263                  } else {
    264                    _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
    265                  }
    266                  xx++;
    267                  if (++CurrentPixel == 2) {
    268                    CurrentPixel = 0;
    269                    Pixels = *(++p);
    270                  }
    271          		  } while (--xsize);
    272              }
    273              break;
    274            }
    275            LCD_L0_DrawBitmap(x, _y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, _Bm.pData, 0, 0);
    276          }
    277          
    278          /*********************************************************************
    279          *
    280          *       _DrawBitLine8BPP
    281          */
    282          static void _DrawBitLine8BPP(int x, U8 const GUI_UNI_PTR * p, int xsize, const LCD_PIXELINDEX * pTrans) {
    283            int xx = x;
    284            LCD_PIXELINDEX Pixel;
    285            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
    286            case 0:
    287              if (pTrans) {
    288                for (; xsize > 0; xsize--, xx++, p++) {
    289                  Pixel = *p;
    290                  _SetPixelIndex(xx, *(pTrans + Pixel));
    291                }
    292              } else {
    293                for (; xsize > 0; xsize--, xx++, p++) {
    294                  _SetPixelIndex(xx, *p);
    295                }
    296              }
    297              break;
    298            case LCD_DRAWMODE_TRANS:
    299              if (pTrans) {
    300                for (; xsize > 0; xsize--, xx++, p++) {
    301                  Pixel = *p;
    302                  if (Pixel) {
    303                    _SetPixelIndex(xx, *(pTrans + Pixel));
    304                  } else {
    305                    _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
    306                  }
    307                }
    308              } else {
    309                for (; xsize > 0; xsize--, xx++, p++) {
    310                  Pixel = *p;
    311                  if (Pixel) {
    312                    _SetPixelIndex(xx, Pixel);
    313                  } else {
    314                    _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
    315                  }
    316                }
    317              }
    318              break;
    319            }
    320            LCD_L0_DrawBitmap(x, _y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, _Bm.pData, 0, 0);
    321          }
    322          
    323          /*********************************************************************
    324          *
    325          *       _DrawBitLine16BPP
    326          */
    327          static void _DrawBitLine16BPP(int x, U16 const GUI_UNI_PTR * p, int xsize, const LCD_PIXELINDEX * pTrans) {
    328            int xx = x;
    329            LCD_PIXELINDEX pixel;
    330            if ((GUI_Context.DrawMode & LCD_DRAWMODE_TRANS) == 0) {
    331              if (pTrans) {
    332                for (; xsize > 0; xsize--, xx++, p++) {
    333                  pixel = *p;
    334                  _SetPixelIndex(xx, *(pTrans + pixel));
    335                }
    336              } else {
    337                for (;xsize > 0; xsize--, xx++, p++) {
    338                  _SetPixelIndex(xx, *p);
    339                }
    340              }
    341            } else {
    342              if (pTrans) {
    343                for (; xsize > 0; xsize--, xx++, p++) {
    344                  pixel = *p;
    345                  if (pixel) {
    346                    _SetPixelIndex(xx, *(pTrans + pixel));
    347                  } else {
    348                    _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
    349                  }
    350                }
    351              } else {
    352                for (; xsize > 0; xsize--, xx++, p++) {
    353                  pixel = *p;
    354                  if (pixel) {
    355                    _SetPixelIndex(xx, pixel);
    356                  } else {
    357                    _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
    358                  }
    359                }
    360              }
    361            }
    362            LCD_L0_DrawBitmap(x, _y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, _Bm.pData, 0, 0);
    363          }
    364          
    365          /*********************************************************************
    366          *
    367          *       Public code
    368          *
    369          **********************************************************************
    370          */
    371          /*********************************************************************
    372          *
    373          *       LCD_L0_DELTA_DrawBitmap
    374          */
    375          void LCD_L0_DELTA_DrawBitmap(int x0, int y0,
    376                                       int xsize, int ysize,
    377                                       int BitsPerPixel, 
    378                                       int BytesPerLine,
    379                                       const U8 GUI_UNI_PTR * pData, int Diff,
    380                                       const LCD_PIXELINDEX* pTrans)
    381          {
    382            int i;
    383            _InitBM(xsize, x0 + Diff);
    384            for (i = 0; i < ysize; i++) {
    385              _y = i + y0;
    386              switch (BitsPerPixel) {
    387              case 1:
    388                _DrawBitLine1BPP(x0, pData, Diff, xsize, pTrans);
    389                break;
    390              #if (LCD_MAX_LOG_COLORS > 2)
    391                case 2:
    392                  _DrawBitLine2BPP(x0, pData, Diff, xsize, pTrans);
    393                  break;
    394              #endif
    395              #if (LCD_MAX_LOG_COLORS > 4)
    396                case 4:
    397                  _DrawBitLine4BPP(x0, pData, Diff, xsize, pTrans);
    398                  break;
    399              #endif
    400              #if (LCD_MAX_LOG_COLORS > 16)
    401                case 8:
    402                  _DrawBitLine8BPP(x0, pData, xsize, pTrans);
    403                  break;
    404              #endif
    405              #if (LCD_BITSPERPIXEL > 8)
    406                case 16:
    407                  _DrawBitLine16BPP(x0, (const U16 *)pData, xsize, pTrans);
    408                  break;
    409              #endif
    410              }
    411              pData += BytesPerLine;
    412            }
    413          }
    414          
    415          /*********************************************************************
    416          *
    417          *       LCD_L0_DELTA_DrawHLine
    418          */
    419          void LCD_L0_DELTA_DrawHLine(int x0, int y,  int x1) {
    420            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
    421              for (; x0 <= x1; x0++) {
    422                LCD_L0_XorPixel(x0, y);
    423              }
    424            } else {
    425              LCD_L0_DELTA_FillRect(x0, y, x1, y);
    426            }
    427          }
    428          
    429          /*********************************************************************
    430          *
    431          *       LCD_L0_DELTA_DrawVLine
    432          */
    433          void LCD_L0_DELTA_DrawVLine(int x , int y0,  int y1) {
    434            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
    435              for (; y0 <= y1; y0++) {
    436                LCD_L0_XorPixel(x, y0);
    437              }
    438            } else {
    439              int aIndex[2];
    440              _SetRGB(LCD_COLORINDEX);
    441              aIndex[0] = x % 3;
    442              aIndex[1] = (x + 1) % 3;
    443              for (; y0 <= y1; y0++) {
    444                LCD_L0_SetPixelIndex(x, y0, _aRGB[aIndex[y0 & 1]]);
    445              }
    446            }
    447          }
    448          
    449          /*********************************************************************
    450          *
    451          *       LCD_L0_DELTA_FillRect
    452          */
    453          void LCD_L0_DELTA_FillRect(int x0, int y0, int x1, int y1) {
    454            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
    455              for (; y0 <= y1; y0++) {
    456                LCD_L0_DELTA_DrawHLine(x0, y0, x1);
    457              }
    458            } else {
    459              int x, y, aInit_0 = 0, aInit_1 = 0;
    460              _InitBM(x1 - x0 + 1, x0);/**/
    461              _SetRGB(LCD_COLORINDEX);
    462              for (y = y0; y <= y1; y++) {
    463                int Index = y & 1;
    464                if (Index) {
    465                  if (!aInit_1) {
    466                    for (x = x0; x <= x1; x++) {
    467                      _aPixelData_1[x] = _aRGB[(x + 1) % 3];
    468                    }
    469                    aInit_1 = 1;
    470                  }
    471                  LCD_L0_DrawBitmap(x0, y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, &_aPixelData_1[x0], 0, 0);
    472                } else {
    473                  if (!aInit_0) {
    474                    for (x = x0; x <= x1; x++) {
    475                      _aPixelData_0[x] = _aRGB[x % 3];
    476                    }
    477                    aInit_0 = 1;
    478                  }
    479                  LCD_L0_DrawBitmap(x0, y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, _Bm.pData, 0, 0);
    480               }
    481              }
    482            }
    483          }
    484          
    485          /*********************************************************************
    486          *
    487          *       LCD_L0_DELTA_GetPixelIndex
    488          */
    489          unsigned int LCD_L0_DELTA_GetPixelIndex(int x, int y) {
    490            return LCD_L0_GetPixelIndex(x, y);
    491          }
    492          
    493          /*********************************************************************
    494          *
    495          *       LCD_L0_DELTA_SetPixelIndex
    496          */
    497          void LCD_L0_DELTA_SetPixelIndex(int x, int y, int ColorIndex) {
    498            LCD_L0_SetPixelIndex(x, y, ColorIndex);
    499          }
    500          
    501          /*********************************************************************
    502          *
    503          *       LCD_L0_DELTA_XorPixel
    504          */
    505          void LCD_L0_DELTA_XorPixel(int x, int y) {
    506            LCD_L0_XorPixel(x, y);
    507          }
    508          
    509          #else
    510          
    511          void LCDL0Delta_c(void);

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    512          void LCDL0Delta_c(void) { } /* avoid empty object files */
   \                     LCDL0Delta_c:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   02....       LJMP    ?BRET

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??LCDL0Delta_c?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    LCDL0Delta_c
    513          
    514          #endif
    515          
    516          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function     ISTACK PSTACK XSTACK
     --------     ------ ------ ------
     LCDL0Delta_c     0      0      0


   Segment part sizes:

     Function/Label       Bytes
     --------------       -----
     LCDL0Delta_c            3
     ??LCDL0Delta_c?relay    6

 
 3 bytes in segment BANKED_CODE
 6 bytes in segment BANK_RELAYS
 
 9 bytes of CODE memory

Errors: none
Warnings: none

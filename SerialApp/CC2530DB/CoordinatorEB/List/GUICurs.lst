###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.10194/W32 for 8051         14/Jun/2016  16:18:33 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Components\uCGUI\Cor #
#                          e\GUICurs.c                                        #
#    Command line       =  -f F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็ #
#                          \WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\U #
#                          tilities\SerialApp\CC2530DB\..\..\..\Tools\CC2530D #
#                          B\f8wCoord.cfg (-DCPU32MHZ -DROOT=__near_func      #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8         #
#                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)    #
#                          -f F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็ #
#                          \WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\U #
#                          tilities\SerialApp\CC2530DB\..\..\..\Tools\CC2530D #
#                          B\f8wConfig.cfg (-DZIGBEEPRO -DSECURE=0            #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0x1001                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโ #
#                          ลฬืสมฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5. #
#                          1a\Components\uCGUI\Core\GUICurs.c -D              #
#                          HAL_UART=TRUE -D SERIAL_APP_PORT=0 -D COOR -D      #
#                          LCD_SUPPORTED -D NV_INIT -lC                       #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\CoordinatorEB\List\ -lA   #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\CoordinatorEB\List\       #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\CoordinatorEB\Obj\ -e     #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็ #
#                          \WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\U #
#                          tilities\SerialApp\CC2530DB\ -I                    #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\Public\ -I             #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \uCGUI\Core\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ2 #
#                          10\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Proj #
#                          ects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\ #
#                          ..\..\Components\uCGUI\MultiLayer\ -I              #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \uCGUI\Config\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสม #
#                          ฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Pr #
#                          ojects\zstack\Utilities\SerialApp\CC2530DB\..\Coor #
#                          dinator\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\Z #
#                          igBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects #
#                          \zstack\Utilities\SerialApp\CC2530DB\..\..\..\ZMai #
#                          n\TI2530DB\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ21 #
#                          0\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Proje #
#                          cts\zstack\Utilities\SerialApp\CC2530DB\..\..\..\. #
#                          .\..\Components\hal\include\ -I                    #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \hal\target\CC2530EB\ -I                           #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \mac\include\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ #
#                          210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Pro #
#                          jects\zstack\Utilities\SerialApp\CC2530DB\..\..\.. #
#                          \..\..\Components\mac\high_level\ -I               #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \mac\low_level\srf04\ -I                           #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \mac\low_level\srf04\single_chip\ -I               #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \mt\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBe #
#                          eอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zst #
#                          ack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\Co #
#                          mponents\osal\include\ -I                          #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \services\saddr\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬื #
#                          สมฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\Components\services\sdata\ -I            #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \stack\af\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210 #
#                          \ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projec #
#                          ts\zstack\Utilities\SerialApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\nwk\ -I                       #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \stack\sapi\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ2 #
#                          10\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Proj #
#                          ects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\ #
#                          ..\..\Components\stack\sec\ -I                     #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \stack\sys\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ21 #
#                          0\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Proje #
#                          cts\zstack\Utilities\SerialApp\CC2530DB\..\..\..\. #
#                          .\..\Components\stack\zdo\ -I                      #
#                          F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\..\..\..\..\..\Components #
#                          \zmac\ -I F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\Zig #
#                          Beeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\z #
#                          stack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\ #
#                          Components\zmac\f8w\ -Ohz --require_prototypes     #
#    List file          =  F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\CoordinatorEB\List\GUICur #
#                          s.lst                                              #
#    Object file        =  F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WS #
#                          N-CSิดย๋\ZStack-CC2530-2.5.1a\Projects\zstack\Util #
#                          ities\SerialApp\CC2530DB\CoordinatorEB\Obj\GUICurs #
#                          .r51                                               #
#                                                                             #
#                                                                             #
###############################################################################

F:\นโลฬืสมฯ\ETC-WSNฮ๏มชอ๘นโลฬืสมฯ210\ZigBeeอ๘ย็\WSN-CSิดย๋\ZStack-CC2530-2.5.1a\Components\uCGUI\Core\GUICurs.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              ตC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : GUICurs.C
     16          Purpose     : Cursor routines of the graphics library
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include <stddef.h>           /* needed for definition of NULL */
     21          #include "GUI_Private.h"
     22          
     23          #if GUI_SUPPORT_CURSOR
     24          
     25          /*********************************************************************
     26          *
     27          *       static data
     28          *
     29          **********************************************************************
     30          */
     31          
     32          static GUI_HMEM          _hBuffer;
     33          static GUI_RECT          _Rect;
     34          static char              _CursorIsVis;        /* Currently visible ? */
     35          static char              _CursorOn;
     36          static const GUI_CURSOR GUI_UNI_PTR * _pCursor;
     37          static U8                _CursorDeActCnt;
     38          static int               _AllocSize;
     39          static int               _x, _y;              /* Position of hot spot */
     40          static GUI_RECT          _ClipRect;
     41          static LCD_PIXELINDEX    _ColorIndex[4];      /* Color-Cache */
     42          
     43          /*********************************************************************
     44          *
     45          *       static code, helper functions
     46          *
     47          **********************************************************************
     48          */
     49          /*********************************************************************
     50          *
     51          *       _SetPixelIndex
     52          *
     53          * Purpose
     54          *   Sets the pixel index for the Cursor.
     55          *   Note the following:
     56          *   - We do the clipping in this routine
     57          *   - We do NOT call the driver directly, but thru its API table.
     58          *     This allows others (e.g. the VNC server) to be in the loop-
     59          */
     60          static void _SetPixelIndex(int x, int y, int Index) {
     61            if ((y >= _ClipRect.y0) && (y <= _ClipRect.y1)) {
     62              if ((x >= _ClipRect.x0) && (x <= _ClipRect.x1)) {
     63                LCD_aAPI[0]->pfSetPixelIndex(x, y, Index);
     64              }
     65            }
     66          }
     67          
     68          /*********************************************************************
     69          *
     70          *       _GetPixelIndex
     71          *
     72          * Purpose
     73          *   Gets a pixel index for the Cursor.
     74          */
     75          static int _GetPixelIndex(int x, int y) {
     76            if ((y >= _ClipRect.y0) && (y <= _ClipRect.y1)) {
     77              if ((x >= _ClipRect.x0) && (x <= _ClipRect.x1)) {
     78                return LCD_L0_GetPixelIndex(x, y);
     79              }
     80            }
     81            return 0;
     82          }
     83          
     84          /*********************************************************************
     85          *
     86          *       _Undraw
     87          *
     88          * Purpose
     89          *   Remove the cursors
     90          */
     91          static void _Undraw(void) {
     92            int x, y, xSize, ySize;
     93            LCD_PIXELINDEX* pData;
     94            /* Save bitmap data */
     95            GUI_LOCK();
     96            if (_hBuffer) {
     97              pData = (LCD_PIXELINDEX*)GUI_ALLOC_h2p(_hBuffer);
     98              xSize = _Rect.x1 - _Rect.x0 + 1;
     99              ySize = _Rect.y1 - _Rect.y0 + 1;
    100              for (y = 0; y < ySize; y++) {
    101                for (x = 0; x < xSize; x++) {
    102                  _SetPixelIndex(x + _Rect.x0, y + _Rect.y0, *(pData + x));
    103                }
    104                pData += _pCursor->pBitmap->XSize;
    105              }
    106            }
    107            GUI_UNLOCK();
    108          }
    109          
    110          /*********************************************************************
    111          *
    112          *       _Log2Phys
    113          */
    114          static int _Log2Phys(int Index) {
    115            if (Index < 4) {
    116              return _ColorIndex[Index];
    117            } else {
    118              LCD_COLOR Color = *(_pCursor->pBitmap->pPal->pPalEntries + Index);
    119              return LCD_Color2Index(Color);
    120            }
    121          }
    122          
    123          /*********************************************************************
    124          *
    125          *       _Draw
    126          */
    127          static void _Draw(void) {
    128            int x, y, xSize, ySize;
    129            LCD_PIXELINDEX* pData;
    130            const GUI_BITMAP GUI_UNI_PTR * pBM;
    131            GUI_LOCK();
    132            if (_hBuffer) {
    133              /* Save bitmap data */
    134              pBM = _pCursor->pBitmap;
    135              pData = (LCD_PIXELINDEX*)GUI_ALLOC_h2p(_hBuffer);
    136              xSize = _Rect.x1 - _Rect.x0 + 1;
    137              ySize = _Rect.y1 - _Rect.y0 + 1;
    138              for (y = 0; y < ySize; y++) {
    139                for (x = 0; x < xSize; x++) {
    140                  int BitmapPixel;
    141                  *(pData + x) = _GetPixelIndex(_Rect.x0 + x, _Rect.y0 + y);
    142                  BitmapPixel = GUI_GetBitmapPixelIndex(pBM, x, y);
    143                  if (BitmapPixel) {
    144                    _SetPixelIndex(_Rect.x0 + x, _Rect.y0 + y, _Log2Phys(BitmapPixel));
    145                  }
    146                }
    147                pData += pBM->XSize;
    148              }
    149            }
    150            GUI_UNLOCK();
    151          }
    152          
    153          /*********************************************************************
    154          *
    155          *       _CalcRect
    156          */
    157          static void _CalcRect(void) {
    158            if (_pCursor) {
    159              _Rect.x0 = _x - _pCursor->xHot;
    160              _Rect.y0 = _y - _pCursor->yHot;
    161              _Rect.x1 = _Rect.x0 + _pCursor->pBitmap->XSize - 1;
    162              _Rect.y1 = _Rect.y0 + _pCursor->pBitmap->YSize - 1;
    163            }
    164          }
    165          
    166          /*********************************************************************
    167          *
    168          *       _Hide
    169          */
    170          static void _Hide(void) {
    171            if (_CursorIsVis) {
    172              _Undraw();
    173              _CursorIsVis = 0;
    174            }
    175          }
    176          
    177          /*********************************************************************
    178          *
    179          *       _Show
    180          */
    181          static void _Show(void) {
    182            if (_CursorOn && (_CursorDeActCnt==0)) {
    183              _CursorIsVis = 1;
    184              _Draw();  
    185            }
    186          }
    187          
    188          /*********************************************************************
    189          *
    190          *       _TempHide
    191          *
    192          * Purpose:
    193          *   Hide cursor if a part of the given rectangle is located in the
    194          *   rectangle used for the cursor. This routine is called automatically
    195          *   by the window manager. This way the window manager can
    196          *   automatically make sure that the cursor is always displayed
    197          *   correctly.
    198          *
    199          * Params:
    200          *   pRect   Rectangle under consideration
    201          *
    202          * Return value:
    203          *   0:      No action taken
    204          *           Cursor was not visible or not affected because rectangles
    205          *           did not overlap
    206          *   1:      Cursor hidden -> WM needs to restore cursor after
    207          *           drawing operation
    208          */
    209          static char _TempHide(const GUI_RECT* pRect) {
    210            if (!_CursorIsVis) {
    211              return 0;             /* Cursor not visible -> nothing to do */
    212            }
    213            if ((pRect == NULL) || GUI_RectsIntersect(pRect, &_Rect)) {
    214              _Hide();              /* Cursor needs to be hidden */
    215              return 1;
    216            }
    217            return 0;               /* Cursor not affected -> nothing to do */
    218          }
    219          
    220          /*********************************************************************
    221          *
    222          *       _TempUnhide
    223          */
    224          static void _TempUnhide(void) {
    225            _Show();
    226          }
    227          
    228          /*********************************************************************
    229          *
    230          *       Public code
    231          *
    232          **********************************************************************
    233          */
    234          /*********************************************************************
    235          *
    236          *       GUI_CURSOR_Activate
    237          */
    238          void GUI_CURSOR_Activate(void) {
    239            GUI_LOCK();
    240            if ((--_CursorDeActCnt) ==0) {
    241              _Show();
    242            }
    243            GUI_UNLOCK();
    244          }
    245          
    246          /*********************************************************************
    247          *
    248          *       GUI_CURSOR_Deactivate
    249          */
    250          void GUI_CURSOR_Deactivate(void) {
    251            GUI_LOCK();
    252            if (_CursorDeActCnt++ ==0)
    253              _Hide();
    254            GUI_UNLOCK();
    255          }
    256          
    257          /*********************************************************************
    258          *
    259          *       GUI_CURSOR_Select
    260          */
    261          const GUI_CURSOR GUI_UNI_PTR * GUI_CURSOR_Select(const GUI_CURSOR GUI_UNI_PTR * pCursor) {
    262            int AllocSize;
    263            const GUI_BITMAP GUI_UNI_PTR * pBM;
    264            const GUI_CURSOR GUI_UNI_PTR * pOldCursor;
    265            GUI_LOCK();
    266            pOldCursor = _pCursor;
    267            if (pCursor != _pCursor) {
    268              int i;
    269              pBM = pCursor->pBitmap;
    270              i = pBM->pPal->NumEntries > 4 ? 4 : pBM->pPal->NumEntries;
    271              while (i--) {
    272                LCD_COLOR Color = *(pBM->pPal->pPalEntries + i);
    273                _ColorIndex[i] = LCD_Color2Index(Color);
    274              }
    275              _Hide();
    276              AllocSize = pBM->XSize * pBM->YSize * sizeof(LCD_PIXELINDEX);
    277              if (AllocSize != _AllocSize) {
    278                GUI_ALLOC_Free(_hBuffer);
    279                _hBuffer = 0;
    280              }
    281              _hBuffer = GUI_ALLOC_AllocZero(AllocSize);
    282              _CursorOn = 1;
    283              _pCursor = pCursor;
    284              _CalcRect();
    285              _Show();
    286            }
    287            GUI_UNLOCK();
    288            return pOldCursor;
    289          }
    290          
    291          /*********************************************************************
    292          *
    293          *       GUI_CURSOR_Hide
    294          */
    295          void GUI_CURSOR_Hide(void) {
    296            GUI_LOCK();
    297            _Hide();
    298            _CursorOn = 0;
    299            /* Set function pointer which window manager can use */
    300            GUI_CURSOR_pfTempHide   = NULL;
    301            GUI_CURSOR_pfTempUnhide = NULL;
    302            GUI_UNLOCK();
    303          }
    304          
    305          /*********************************************************************
    306          *
    307          *       GUI_CURSOR_Show
    308          */
    309          void GUI_CURSOR_Show(void) {
    310            GUI_LOCK();
    311            LCDDEV_L0_GetRect(&_ClipRect);
    312            _Hide();
    313            _CursorOn = 1;
    314            /* Set function pointer which window manager can use */
    315            GUI_CURSOR_pfTempHide   = _TempHide;
    316            GUI_CURSOR_pfTempUnhide = _TempUnhide;
    317            if (!_pCursor) {
    318              GUI_CURSOR_Select(GUI_DEFAULT_CURSOR);
    319            } else {
    320              _Show();
    321            }
    322            GUI_UNLOCK();
    323          }
    324          
    325          /*********************************************************************
    326          *
    327          *       GUI_CURSOR_SetPosition
    328          */
    329          void GUI_CURSOR_SetPosition(int xNewPos, int yNewPos) {
    330            int x, xStart, xStep, xEnd, xOff, xOverlapMin, xOverlapMax;
    331            int y, yStart, yStep, yEnd, yOff, yOverlapMin, yOverlapMax;
    332            int xSize;
    333            LCD_PIXELINDEX* pData;
    334            GUI_LOCK();
    335            if (_hBuffer) {
    336              if ((_x != xNewPos) | (_y != yNewPos)) {
    337                if (_CursorOn) {
    338                  const GUI_BITMAP GUI_UNI_PTR * pBM = _pCursor->pBitmap;
    339                  /* Save & set clip rect */
    340                  /* Compute helper variables */
    341                  pData = (LCD_PIXELINDEX*)GUI_ALLOC_h2p(_hBuffer);
    342                  xSize = _pCursor->pBitmap->XSize;
    343                  xOff = xNewPos - _x;
    344                  if (xOff > 0) {
    345                    xStep  = 1;
    346                    xStart = 0;
    347                    xEnd   = _pCursor->pBitmap->XSize;
    348                    xOverlapMax = xEnd -1;
    349                    xOverlapMin = xOff;
    350                  } else {
    351                    xStep  = -1;
    352                    xStart = xSize - 1;
    353                    xEnd   = -1;
    354                    xOverlapMin = 0;
    355                    xOverlapMax = xStart + xOff;
    356                  }
    357                  yOff = yNewPos - _y;
    358                  if (yOff > 0) {
    359                    yStep  = 1;
    360                    yStart = 0;
    361                    yEnd   = _pCursor->pBitmap->YSize;
    362                    yOverlapMax = yEnd -1;
    363                    yOverlapMin = yOff;
    364                  } else {
    365                    yStep  = -1;
    366                    yStart = _pCursor->pBitmap->YSize - 1;
    367                    yEnd   = -1;
    368                    yOverlapMin = 0;
    369                    yOverlapMax = yStart + yOff;
    370                  }
    371                  /* Restore & Draw */
    372                  for (y = yStart; y != yEnd; y += yStep) {
    373                    char yOverlaps;
    374                    char yNewOverlaps;
    375                    int yNew = y + yOff;
    376                    yOverlaps    = (y >= yOverlapMin) && (y <= yOverlapMax);
    377                    yNewOverlaps = (yNew >= yOverlapMin) && (yNew <= yOverlapMax);
    378                    for (x= xStart; x != xEnd; x += xStep) {
    379                      char xyOverlaps, xyNewOverlaps;
    380                      int BitmapPixel;
    381                      LCD_PIXELINDEX Pixel;
    382                      LCD_PIXELINDEX* pSave = pData + x + y * xSize;
    383                      int xNew = x + xOff;
    384                      BitmapPixel = GUI_GetBitmapPixelIndex(pBM, x, y);
    385                      xyOverlaps    = (x    >= xOverlapMin) && (x    <= xOverlapMax) && yOverlaps;
    386                      xyNewOverlaps = (xNew >= xOverlapMin) && (xNew <= xOverlapMax) && yNewOverlaps;
    387                      /* Restore old pixel if it was not transparent */
    388                      if (BitmapPixel) {
    389                        if (!xyOverlaps || (GUI_GetBitmapPixelIndex(pBM, x - xOff, y - yOff) == 0)) {
    390                          _SetPixelIndex(x + _Rect.x0, y + _Rect.y0, *(pSave));
    391                        }
    392                      }
    393                      /* Save */
    394                      if (xyNewOverlaps) {
    395                        Pixel = *(pData + xNew + yNew * xSize);
    396                      } else {
    397                        Pixel = _GetPixelIndex(_Rect.x0 + xNew, _Rect.y0 + yNew);
    398                      }
    399                      *pSave = Pixel;
    400                      /* Write new  ... We could write pixel by pixel here */
    401                      if (BitmapPixel) {
    402                        LCD_PIXELINDEX NewPixel = _Log2Phys(BitmapPixel);
    403                        _SetPixelIndex(_Rect.x0 + xNew, _Rect.y0 + yNew, NewPixel);
    404                      }
    405                    }
    406                  }
    407                }
    408                _x = xNewPos;
    409                _y = yNewPos;
    410                _CalcRect();
    411              }
    412            }
    413            GUI_UNLOCK();
    414          }
    415          
    416          #else
    417          
    418          void GUICurs_C(void);

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    419          void GUICurs_C(void) {} /* avoid empty object files */
   \                     GUICurs_C:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   02....       LJMP    ?BRET

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GUICurs_C?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GUICurs_C
    420          
    421          #endif   /* GUI_SUPPORT_CURSOR */
    422          
    423          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function  ISTACK PSTACK XSTACK
     --------  ------ ------ ------
     GUICurs_C     0      0      0


   Segment part sizes:

     Function/Label    Bytes
     --------------    -----
     GUICurs_C            3
     ??GUICurs_C?relay    6

 
 3 bytes in segment BANKED_CODE
 6 bytes in segment BANK_RELAYS
 
 9 bytes of CODE memory

Errors: none
Warnings: none
